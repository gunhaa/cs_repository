# 4. 조인 튜닝

## NL(Nested Loop) 조인

> 인덱스를 이용한 기본적인 조인 방법

- 아래 SQL을 코드로 나타내면 다음과 같은 수행구조이다(Nested Loop)
```sql
select e.사원명, c.고객명, c.전화번호
from 사원 e, 고객c
where e. 입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```
```java
for(int i=0; i<100; i++) {
    for(int j=0l j<100; j++){
        // Do something...
    }
}
```
- 사원e 테이블을 iteration하며 같은 것을 찾아 테이블로 만들어내는 것이 핵심이다
  - SQL에서 양 테이블의 index를 이용해 위 java코드의 nested loop를 이용해 join 하는 것이 nl join이다
    - 즉, NL Join은 외부 테이블(사원)을 순회하면서, 내부 테이블(고객)을 인덱스로 빠르게 조회해 조건에 맞는 행을 찾는 방식이다
- 위 SQL에서는 JOIN 키워드를 명시적으로 사용하지 않았더라도, SQL에서 FROM A, B WHERE A.key = B.key 형태로 작성하면 옵티마이저가 내부적으로 조인을 수행한다.

### 제어 방법

- use_nl 힌트를 사용한다
```sql
select /*+ ordered use_nl(c)*/
        e.사원명, c.고객명, c.전화번호
from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and   c.관리사원번호 = e.사원번호
```

### Where문과 Join문의 차이

- JOIN 문이 표준 SQL, 가독성, 유지보수성 모두에서 더 우수하다
- WHERE 방식은 복잡한 힌트 기반 성능 튜닝이 필요할 때만 사용하는 것이 일반적이다

| 항목           | `FROM A, B WHERE A.id = B.id` (암시적 조인) | `FROM A JOIN B ON A.id = B.id` (명시적 조인) |
|----------------|--------------------------------------------|----------------------------------------------|
| 기본 의미      | INNER JOIN과 동일                         | 명시적으로 INNER / OUTER JOIN 표현 가능     |
| 가독성         | 복잡한 쿼리에서 가독성 떨어질 수 있음      | 조인 구조가 명확하여 가독성 우수             |
| 외부 조인 표현 | `(+)` 등 벤더 종속적 문법 사용 필요        | `LEFT JOIN`, `RIGHT JOIN` 등 표준 SQL 지원   |
| 조인 조건 위치 | `WHERE` 절에서 명시                       | `ON` 절에서 명시                              |
| 힌트 적용 편의 | `ORDERED`, `USE_NL`, `LEADING` 등 명확 적용 가능 | 힌트 적용이 다소 불명확하거나 제한적일 수 있음 |
| 옵티마이저 통제 | 조인 순서 및 방식 통제가 쉬움              | 통제하려면 추가 힌트가 필요하거나 어려움     |

### NL조인 예제와 튜닝 포인트

> WHERE 문에서는 작성 순서와 관계없이, 옵티마이저가 내부적으로 가장 비용(Cost)이 낮은 조인 순서와 실행 계획을 선택한다.

```sql
select /* ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자,
       c.고객번호, c.고객명, c.전화번호, c.최종주문 금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호   ...1
and e.입사일자 >= '19960101'       ...2
and e.부서코드 = 'Z123'            ...3
and c.최종주문금액 >= 20000         ...4

-- 인덱스 구성
사원_PK: 사원번호
사원_X1: 입사일자
고객_PK: 고객번호
고객_X1: 관리사원번호
고객_X2: 최종주문금액

-- 실행 계획
----------------------------------------------------------------------------
| ID | OPERATION                       |   NAME  |  Rows | Bytes | Cost |
----------------------------------------------------------------------------
|  0 | SELECT STATEMENT                |         |   5   |  58   |   5  |
|  1 |  NESTED LOOPS                   |         |   5   |  58   |   5  |
|  2 |   TABLE ACCESS BY INDEX ROWID  |  사원    |   3   |  20   |   2  | -- 부서코드 = 'Z123' 사용
|  3 |    INDEX RANGE SCAN            |  사원_X1 |   5   |       |   1  | -- e.입사일자 >= '19960101' 사용
|  4 |   TABLE ACCESS BY INDEX ROWID  |  고객    |   5   |  76   |   2  | -- 최종주문금액 >= 20000 사용
|  5 |    INDEX UNIQUE SCAN            | 고객_X1 |   8   |       |   1  | -- c.관리사원번호 = e.사원번호 사용
---------------------------------------------
```

![img1](images/joinTuning1.png)

- 이곳의 실행 계획은, 각 단계를 완료하고 다음 단계로 넘어가는 것이 아니라 한 레코드씩 순차적으로 진행된다
- ID순서대로 실행되지 않는다
- 2 -> 3 -> 1 -> 4 순으로 진행된다
  1. 사원_X1, index range scan(2)
  2. 읽은 ROWID로 부서코드='Z123' 필터 조건 확인(3)
  3. 사원 테이블에서 읽은 값으로 고객 레코드를 찾기위해 고객_X1 index range scan(1)
  4. 고객_X1 index에서 읽은 ROWID를 이용해 고객테이블에 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는 것을 확인한다(4)
- 해당 계획에서의 튜닝 포인트는 2가지가 있다
  1. 사원_X1을 읽은 후 사원테이블 엑세스 부분
     - 위 예제는 '=' 스캔으로 인해 잘됬음
  2. 고객_X1을 읽은 후 인덱스 탐색 부분
     - 최종주문금액 >= 20000 에 필터링 되는 비율이 높다면, 고객_X1 인덱스에 최종 주문 금액 컬럼을 추가하는 방안을 고려해야한다(RANDOM ACCESS 최소화)

### NL join Recap

- NL 조인의 중요한 특징
  1. 랜덤 액세스 위주의 조인이다
     - 레코드를 읽기 위해 블록을 통째로 읽는 랜덤 액세스 방식은 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다
       - 인덱스 구성이 아무리 완벽하더라도 대량 데이터 조인에서 NL조인이 불리한 이유이다 
  2. 조인을 한 레코드씩 순차적으로 진행한다
     - 첫번째 특징 때문에 대량 데이터 처리시 치명적인 한계가 있지만, 이 두 번째 특징때문에 아무리 큰 테이블에 조인하더라도 빠른 응답 속도를 낼 수 있다(부분범위 처리가 가능한 상황에서) 
     - 이 특징은 DBMS시스템의 Lazy Loading이나 Cursor 기반 처리를 이야기한다
  3. 인덱스 구성 전략이 특히 중요하다
     - 조인 컬럼에 인덱스가 있느냐, 있다면 컬럼이 어떻게 구성 됐느냐에 따라 조인 효율이 크게 달라진다
  4. NL조인은 소량 데이터를 주로 처리하거나 부분 범위 처리가 가능한 온라인 트랜잭션 처리(OLTP) 시스템에 적합한 조인 방식이다

### NL조인 잘못된 예제와 해결

```sql
-- index 생성 요청
PRA_HST_STC_N1 : SALE_ORG_ID + STRD_GRP_ID + STRD_ID + STC_DT

-- 사용 쿼리
select * 
from PRA_HST_STC a, ODM_TRMS b
where a.SALE_ORG_ID = :sale_org_id
and   a.STRD_GRP_ID = b.STRD_GRP_ID
and   a.STRD_ID     = b.STRD_ID
and   b.TRMS_DT     = :trms_dt
order by a.STC_DT desc
```

- 위 요청은 잘못되었다 
  - PRA_HST_STC 인덱스는 현재 조인 컬럼이 이중으로 들어가 있다
  - 조인 키 중 하나만 남겨야한다 (STRD_ID or STRD_GRP_ID)