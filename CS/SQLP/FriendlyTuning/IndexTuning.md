# 3. 인덱스 튜닝

- SQL튜닝은 랜덤 I/O와의 전쟁이다
- SQL 성능 향상을 위해 DBMS가 제공하는 많은 기능은 느린 랜덤 I/O를 극복하기 위해 개발됐다
- 조인 메소드의 발전은 물론 많은 튜닝 기법도 랜덤 I/O 최소화에 맞춰져 있다
  - 여기서 말하는 랜덤 I/O(Random I/O)는 "무작위"라는 의미가 아닌 디스크에서 데이터에 접근할 때 연속된 공간이 아니라 흩어진(비연속적인) 위치에 있는 데이터를 읽는 것을 뜻한다.

## Index의 ROWID란 무엇인가?

> 대량 데이터를 조회할 때 오히려 풀테이블 스캔보다 인덱스 스캔이 더 느려질 수 있다
> 그 이유는 바로 ROWID 때문이다

```sql
SQL> select * from 고객 where 지역 = '서울';
Execution Plan
------------------------------------------
0    SELECT STATEMENT Optimizer=ALL_ROWS
1 0   TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
2 1    INDEX RANGE SCAN OF '고객_지역_IDX' (INDEX)
```

- INDEX 스캔을 하는 이유는 검색조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 주소값 ROWID를 얻으려는데 있다
  - ROWID는 포인터가 아닌, 논리적 주소이다
    - RDBMS마다 다르지만 일반적으로 물리적 위치를 직접 가리키기보단, 간접 식별할 수 있는 정보이다.
  - 포인터처럼 0에 가까운 COST가 드는 것이 아니라, 논리적인 주소로 되어있어서 접근하는데 많은 비용이든다
    - ROWID로 테이블에 접근하려면 디스크 I/O가 반드시 발생한다.
    - 특히 InnoDB에서는 인덱스 리프 노드에서 PK를 얻고, 그 PK로 다시 테이블을 조회해야 한다.
  - 그래서 대용량 데이터를 가진 테이블에서 꽤나 많은 데이터를 INDEX스캔으로 찾는다면, 접근하는데 많은 비용이 들어가 풀 테이블 스캔보다 효율이 떨어지는 상황이 나올 수도 있는 것이다
    - 조건에 맞는 row가 너무 많을 때 (예: 전체의 20~30% 이상)
    - 인덱스에서 수천 개를 찾고 → 다시 수천 번 테이블로 점프해야 한다면 → 랜덤 I/O 폭탄
    - 이럴 바엔 처음부터 Full Table Scan(연속 I/O)이 더 빠를 수 있다
    - 이 문제를 해결하기 위해 인덱스 튜닝을 하여야 한다
  - ROWID는 DB가 해석할 수 있는 위치 정보이며, 하드웨어 수준의 포인터는 아니다. 그러나 DB 내부에서는 가장 빠르게 특정 레코드에 접근할 수 있는 수단이므로, 마치 포인터처럼 쓰일 수 있는 “논리적 주소”라고 보면 된다.

### Oracle ROWID의 구성요소

- Oracle의 ROWID는 물리적 저장 위치를 암시적으로 표현하며, 다음 요소로 구성된다

| 구성 요소            | 설명                            |
| -------------------- | ------------------------------- |
| 데이터 오브젝트 번호 | 테이블 또는 세그먼트의 ID       |
| 파일 번호            | 행이 저장된 데이터 파일의 번호  |
| 블록 번호            | 행이 저장된 블록(Block) 번호    |
| 슬롯 번호 (오프셋)   | 블록 내에서의 행(Row) 위치 정보 |

## 인덱스 클러스터링 팩터(CF)

> 군집성 계수 라고 표현하는 것이 가장 맞다

![img1](images/indexTuning1.png)

- 인덱스의 순서와 테이블의 실제 레코드 저장 순서가 얼마나 잘 정렬되어 있는지를 수치로 나타낸 값이다.
- 수치가 낮을수록 좋다 (인덱스 순서와 테이블 레코드의 물리적 저장 순서가 비슷하다는 뜻)
- 수치가 높을수록 나쁘다 (인덱스의 연속된 값이 테이블에서는 이리저리 흩어져 있다는 뜻 → 랜덤 I/O가 많아짐)

### index가 레코드가 다른 ROWID를 가르킨다면, 군집성과 상관없이 모두 검색하는건데 왜 중요한가?

- (오라클의 경우) 인덱스 ROWID로 테이블에 엑세스할 때, 어렵게 찾아간 테이블 블록에 대한 메모리 주소값을 해제하지 않고 일단 유지하고 마침 '직전과 같은' 테이블 블록을 가르킨다면 검색과정을 생략하고 테이블 블록을 읽을 수 있다
  - 즉, 논리적인 블록 I/O과정을 생략할 수 있는 것이다
  - 즉 군집성(CF)이 좋을수록 인덱스의 성능을 향상 시킬 수 있다

### 그럼 인덱스에 따라 저장 순서를 선형으로 만드는게 가장 좋을텐데 그렇게는 왜 안함?

- 정렬된 저장이 성능에 유리하다는 건 맞다
  - 인덱스가 user_id 오름차순이면, 테이블 레코드도 그 순서대로 정렬돼 있으면 좋다
  - 이러면 인덱스 따라갈 때마다 같은 블록에 계속 접근하게 되고, 디스크 I/O가 거의 안 생긴다
  - 이런 구조를 클러스터형 테이블(Clustered Table) 또는 Index-Organized Table (IOT)이라고 부른다 (특히 Oracle/MySQL에서)
- 그런데 일반적으로 그렇게 저장하지 않는 이유
  - 데이터는 계속 추가·수정·삭제됨 (동적)
  - 테이블은 쓰기(write)가 계속 발생하는 구조다
  - 인덱스 순서대로 정렬 저장하려면, 새로운 데이터가 삽입될 때마다 정렬된 위치를 찾아 옮겨야 함
  - 블록 분할(split), 재배치 등 과도한 디스크 조작이 발생
  - 유지비용이 너무 크다
- 예상된 데이터 분포나 크기를 미리 모를 수 있음
  - 만약 특정 필드에 대해 고르게 정렬 저장할 필요가 있다면, 데이터가 어느 범위로 들어올지 예측해야 함
  - 현실에서는 사용자가 user_id 1 ~ 1,000,000으로 올지, UUID, 혹은 이메일로 올지 미리 모르거나 불균형할 수 있다
- 모든 쿼리가 같은 인덱스를 쓰지 않음
  - 어떤 쿼리는 user_id를, 어떤 쿼리는 created_at을, 또 어떤 쿼리는 email을 기준으로 정렬하거나 검색한다
  - 한 테이블은 한 기준으로밖에 물리적으로 정렬될 수 없다.
  - 어떤 쿼리엔 이득이지만, 다른 쿼리에겐 손해다
- 그래서 일부 상황에서만 사용한다
  - 삽입/갱신이 없는 정적 테이블에 사용된다
  - 범위 검색이 빈번한 테이블에 사용된다
  - 정렬된 출력이 항상 필요한 테이블
- 정렬 저장은 이상적이지만 현실적으론 trade-off가 크다

## 인덱스 손익 분기점

![img2](images/indexTuning2.png)

- 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조이다
- 따라서 읽어야 할 데이터가 일정량을 넘어서는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다
-
