# 역색인 Inverted Index

- 역색인(Inverted Index)은 전문 검색(Full-Text Search) 엔진의 핵심적인 자료 구조로, "어떤 단어가 어떤 문서에 포함되어 있는가?"를 빠르게 찾아내기 위해 사용된다.
- 역색인에 가장 쉬운 비유는 책 맨 뒤에 있는 '찾아보기'이다. 책의 내용을 전부 읽지 않고도 '역색인'이라는 단어가 52페이지, 108페이지에 있다는 것을 바로 알 수 있는 것과 같은 원리이다.

## 데이터 예시 (RAW)

- data 1: `쌀다팜 보이즈의 음악은 독특하고 신선하다.`
- data 2: `요즘 쌀다팜 보이즈 콘서트가 화제다.`
- data 3: `나는 쌀다팜 보이즈의 새로운 앨범을 기대하고 있다.`

---

## 1단계: 토큰화 및 위치 기록 (Tokenization & Positioning)

- 각 문서를 단어(토큰) 단위로 쪼개고, 각 단어의 순서(위치)를 함께 기록한다.
- data 1: `쌀다팜(1)`, `보이즈(2)`, `음악(3)`, `독특(4)`, `신선(5)`
- data 2: `요즘(1)`, `쌀다팜(2)`, `보이즈(3)`, `콘서트(4)`, `화제(5)`
- data 3: `쌀다팜(1)`, `보이즈(2)`, `새로운(3)`, `앨범(4)`, `기대(5)`

---

## 2단계: 불용어 제거 (Stopword Filtering)

예: `은`, `의`, `가`, `을`, `를`, `하고`, `있다` 등

- data 1: `쌀다팜`, `보이즈`, `음악`, `독특`, `신선`
- data 2: `요즘`, `쌀다팜`, `보이즈`, `콘서트`, `화제`
- data 3: `쌀다팜`, `보이즈`, `새로운`, `앨범`, `기대`

---

## 3단계: 역색인 생성 (Inverted Indexing)

단어를 기준으로, 해당 단어가 어떤 문서의 어떤 위치(index)에 나타나는지를 기록한다.

| 단어   | 포함된 (문서 ID, [위치])     |
| ------ | ---------------------------- |
| 쌀다팜 | (1, [1]), (2, [2]), (3, [1]) |
| 보이즈 | (1, [2]), (2, [3]), (3, [2]) |
| 음악   | (1, [3])                     |
| 독특   | (1, [4])                     |
| 신선   | (1, [5])                     |
| 요즘   | (2, [1])                     |
| 콘서트 | (2, [4])                     |
| 화제   | (2, [5])                     |
| 새로운 | (3, [3])                     |
| 앨범   | (3, [4])                     |
| 기대   | (3, [5])                     |

---

## 역색인을 이용한 검색 과정: 구문 검색 `쌀다팜 보이즈`

사용자가 `쌀다팜 보이즈`라는 정확한 구문을 검색하면, DBMS은 다음과 같이 동작한다.

1. 단어별 문서 및 위치 목록 조회

- '쌀다팜': (1, [1]), (2, [2]), (3, [1])
- '보이즈': (1, [2]), (2, [3]), (3, [2])

2. 교집합 문서 찾기

- 두 단어가 모두 포함된 문서는 `[1, 2, 3]`

3. 위치 비교

- 각 문서에서 `보이즈 위치 == 쌀다팜 위치 + 1` 조건을 확인

| 문서 ID | 쌀다팜 위치 | 보이즈 위치 | 조건 일치 여부 |
| ------- | ----------- | ----------- | -------------- |
| 1       | 1           | 2           | 일치           |
| 2       | 2           | 3           | 일치           |
| 3       | 1           | 2           | 일치           |

### 결과 반환

- 최종적으로 문서 1, 2, 3이 검색 결과로 반환된다.

---

### 반례: "쌀다팜 앨범" 검색

- '쌀다팜': (1, [1]), (2, [2]), (3, [1])
- '앨범': (3, [4])

→ 교집합 문서: `[3]`

→ `앨범 위치(4)` ≠ `쌀다팜 위치(1) + 1`

→ 위치 조건 불일치 → 검색 결과 없음

---

## 왜 역색인이 효율적인가?

기존 `LIKE '%검색어%'` 방식은 모든 문서를 처음부터 끝까지 탐색하는 Full Scan 방식으로, 문서 수가 많아질수록 매우 느려진다.

반면, 역색인은 미리 구축된 단어 → (문서, 위치) 리스트를 사용하여,

- 특정 단어가 포함된 문서를 빠르게 조회하고,
- 단어들의 상대적 위치나 순서까지 계산 가능하기 때문에  
  → 정확한 구문 검색이 가능하며 검색 속도도 매우 빠르다.

## 역색인의 단점 (Trade-offs)

> 역색인은 매우 강력하지만, 모든 인덱스와 마찬가지로 단점도 존재한다. 특히 일반적인 B-Tree 인덱스와 비교했을 때, 저장 공간과 유지보수 비용 측면에서 그 트레이드오프가 더욱 명확해진다.

1. 더 큰 저장 공간 필요

   - 일반 인덱스(B-Tree): 컬럼의 값 자체를 정렬하여 저장하므로, 원본 데이터 크기에 비례하여 예측 가능한 수준의 공간을 차지한다.
   - 역색인: 원본 텍스트를 수많은 단어로 쪼개고, 모든 단어에 대해 어느 문서, 어느 위치에 있는지에 대한 정보를 전부 저장한다. 이 때문에 원본 텍스트 데이터의 크기보다 역색인 데이터의 크기가 몇 배로 더 커지는 경우가 흔하다. 이는 검색 속도를 위해 저장 공간을 희생하는 '공간-시간 트레이드오프(Space-Time Tradeoff)'의 전형적인 예시이다.

2. 데이터 추가/수정/삭제 시 비용 발생(Index와 같은 문제)
   - 일반 인덱스(B-Tree): 데이터가 변경되면 정렬된 트리 구조 내에서 자신의 위치를 찾아가 재정렬하는 작업이 발생한다.
   - 역색인: 데이터가 변경되면 '토큰화 → 불용어 처리 → 역색인 목록 업데이트' 라는 훨씬 복잡한 과정을 거친다. 문서 하나가 수정되어도 그 안에 포함된 수많은 단어들의 인덱스 정보를 모두 수정해야 하므로, 단순 데이터 추가보다 훨씬 많은 연산을 필요로 한다. 따라서 쓰기(Write) 작업이 읽기(Read) 작업보다 훨씬 빈번한 시스템에는 큰 부담이 될 수 있다.

- 결론: 역색인은 저장 공간과 쓰기 비용을 희생하여 압도적인 텍스트 검색 속도를 얻는 기술이다. 따라서 검색 기능이 매우 중요한 서비스에 적합하다.

---

## RECAP

- 단순 역색인: 단어의 존재 여부만 확인
- 위치 포함 역색인: 단어의 순서와 거리까지 확인 가능  
  → 따라서 `정확한 문장 검색`이나 `근접어 검색`에 매우 유용하다
