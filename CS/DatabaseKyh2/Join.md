# Join

## Join이 필요한 이유

### 만약 모든 데이터를 하나의 테이블에 저장한다면?

- 궁금증을 해결하기 위해, `users`, `products`, `orders` 테이블을 모두 제거하고, 이 테이블의 필드를 하나로 합친 `all_in_one` 테이블을 상상해 보자

#### [상상 속의 거대한 테이블]

| order_id | order_date | user_name | user_email | product_name | price | quantity |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | 2025-06-10 | 션 | sean@... | 프리미엄 게이밍 마우스 | 75000 | 1 |
| 2 | 2025-06-10 | 션 | sean@... | 관계형 데이터베이스 입문 | 28000 | 2 |
| 3 | 2025-06-11 | 네이트 | nate@... | 기계식 키보드 | 120000 | 1 |
| ... | ... | ... | ... | ... | ... | ... |

- 당장은 편해 보인다. 
- 하지만 이런 방식은 실무에서 재앙을 불러온다. 
- 왜냐하면 다음과 같은 심각한 문제들이 발생하기 때문이다.

1.  데이터 중복 (Redundancy)

    '션' 고객이 상품을 100번 주문했다고 생각해 보자. 그의 이름, 이메일, 주소 정보가 100번이나 불필요하게 반복 저장된다. 이건 매우 큰 저장 공간의 낭비다.

2.  갱신 이상 (Update Anomaly)
    
    만약 '션' 고객이 이메일 주소를 변경했다고 가정해 보자. 우리는 '션'이 주문한 100개의 주문 데이터를 모두 찾아서, 이메일 정보를 일일이 새로운 주소로 변경해야 한다. 만약 실수로 단 하나라도 누락한다면? 어떤 주문에서는 고객의 이메일이 예전 주소로, 다른 주문에서는 새 주소로 저장되어 데이터의 일관성이 깨져버린다. 어떤 정보가 진짜인지 믿을 수 없게 되는 것이다.

3.  삽입 이상 (Insertion Anomaly)
    
    우리 쇼핑몰에 아직 아무도 주문하지 않은 새로운 상품 '초경량 노트북'을 등록하고 싶다. 하지만 이 테이블 구조에서는 '주문'이 발생해야만 데이터를 추가할 수 있다. 주문한 사람이 없으니, 상품 정보조차 등록할 수 없는 말도 안 되는 상황이 발생한다.

4.  삭제 이상 (Deletion Anomaly)
    
    '이순신' 고객이 딱 한 번 주문한 기록이 있다고 하자. 만약 회사 정책상 이 주문 기록을 삭제해야 한다면 어떻게 될까? 주문 데이터를 삭제하는 순간, '이순신' 고객의 이름, 이메일, 주소 정보까지 데이터베이스에서 영원히 사라져 버릴 수 있다. 우리는 단지 주문 내역 하나를 지웠을 뿐인데, 소중한 고객 정보까지 잃게 되는 것이다.

- 이러한 문제들 때문에 우리는 데이터베이스를 설계할 때 정규화(Normalization)라는 과정을 거친다. 
- 정규화는 데이터의 중복을 최소화하고, 데이터의 일관성을 해치는 '이상 현상'들을 방지하기 위해 데이터를 논리적인 단위로 분리하는 과정이다. 
- 우리가 `users`, `products`, `orders` 로 테이블을 나눈 것이 바로 이 정규화의 결과물이다.

> 정규화
>
> 정규화는 데이터베이스 설계의 기본을 이루는 중요한 이론이다.
> 정규화에 대한 자세한 내용은 데이터베이스 설계 강의에서 다룬다.
> 지금은 이런 문제들 때문에 여러 테이블에 나누어 저장한다는 것 정도만 대략 이해하면 충분하다.

### 그래서 조인이 필요하다

- 이제 우리는 왜 데이터를 분리해서 저장하는지 이해했다. 
  - 데이터의 중복을 막고, 일관성을 지키기 위해서다. 
  - 즉, 데이터를 '잘 관리하기 위해서'다. 
  - 하지만 잘 관리하기 위해 흩어놓은 데이터에서 의미 있는 정보를 얻으려면, 이 흩어진 조각들을 다시 합쳐야만 한다. 
  - "어떤 고객이 어떤 상품을 주문했는지"와 같은 통합된 보고서를 만들기 위해, 분리된 테이블들을 다시 연결해야 하는 것이다.
- 이때 사용하는 기술이 바로 조인(`JOIN`)이다.


## 내부(Inner) Join

- 두 테이블을 연결할 때, 양쪽 테이블에 공통으로 존재하는 데이터만을 결과로 보여준다
  - 기준이 되는 컬럼의 값이 서로 일치하는 행들만 짝을 지어주는 것이다(orders.user_id 와 users.user_id)
- inner join은 `쇼핑몰에 가입은 했지만 아직 한 번도 주문하지 않은 고객`을 찾지 못한다
  - inner join은 양쪽에 모두 데이터가 있는 경우만 보여주기 때문에 이 질문에는 답할 수 없다
  - 이 문제를 해결하기 위해서는 외부 조인(outer join)을 사용해야 한다

### 내부 조인 문법
```sql
SELECT 컬럼1, 컬럼2, ...
FROM 테이블A
INNER JOIN 테이블B
ON 테이블A.연결컬럼 = 테이블B.연결컬럼;
```

- `FROM` : 기준이 되는 첫 번째 테이블을 지정한다.
- `INNER JOIN` : 연결할 두 번째 테이블을 지정한다.
- `ON` : 조인에서 가장 중요한 부분이다.
  - 두 테이블을 어떤 조건으로 연결할지 명시하는 연결고리다.
  - `ON` 절의 조건이 참(true)이 되는 행들만 결과에 포함된다.


### 조인의 작동 순서

```sql
SELECT
    users.user_id,
    users.name,
    orders.order_date
FROM orders
INNER JOIN users ON orders.user_id = users.user_id
WHERE orders.status = 'COMPLETED';
```

- 논리적 처리 순서
  - `FROM/JOIN (테이블 결합)` → `WHERE (조건 필터링)` → `SELECT (컬럼 선택)`

#### 논리적 처리 순서와 달라질 수 있다: 쿼리 옵티마이저의 개입

- 사용자와 데이터베이스 간의 논리적 순서는 일종의 약속이지만, 데이터베이스 내부의 쿼리 최적화기 (Query Optimizer)는 쿼리를 더 효율적인 방식으로 실행한다
- 예를 들어, `orders` 테이블에서 `COMPLETED` 상태의 행만 먼저 선택한 다음, 남은 행을 기준으로 `users` 테이블과 조인하는 방식으로 진행하면 조인 대상이 줄어들어 성능이 더 최적화 될 수 있다.
  - 총 100만 개의 레코드가 존재하는 orders 테이블에서 `COMPLETED`가 10건 밖에 없다면 옵티마이저의 판단으로 레코드만 먼저 찾은후 연결시키는 방식으로 순서를 바꿀 수 있다
- 쿼리 최적화기를 통해 실제 물리적인 실행 순서는 달라질 수 있지만 어떻게 작동하든 최종 결과는 논리적인 순서와 동일하다. 
- 하지만 데이터베이스의 최적화 방식을 잘 이해하면 같은 결과를 얻으면서도 조회 성능을 최적화할 수 있다

### 조인과 집합

- Inner join은 A집합과 B집합에 모두 포함된 user_id에 해당하는 데이터만을 결합하여 보여준다
  - 내부 조인(Inner join)은 벤 다이어그램에서 둘의 겹친 영역인 교집합 영역을 뜻한다
- 내부 조인은 양방향이다
  - A 테이블과 B테이블이 있다고하면 A -> B 조인이 가능하다면, B-> A 조인도 가능하다
    - 그리고 그 결과는 항상 같다

#### 조인의 순서는 언제 중요할까?

- 내부 조인에서는 결과가 같으므로 어떤 순서로 작성해도 무방하다
- 하지만 쿼리를 읽는 사람의 입장에서 어떤 데이터가 중심이 되는가에 따라 순서를 정하면 가독성이 높아진다
  - 주문 목록을 중심으로 고객 정보를 추가하고 싶다면 `from orders join users`
  - 고객 목록을 중심으로 주문 정보를 조회하고 싶다면 `from users join orders`
- outer join에서는 조인순서가 결과에 매우 큰 영향을 미친다
  - 하지만 inner join에서는 교집합을 선택하기 때문에 순서와 상관없이 결과는 항상 같다

## 외부(Outer) join

- `우리 쇼핑몰에 가입은 했지만, 아직 한 번도 주문하지 않은 고객은 누구일까?`
- `야심차게 출시했지만, 아직 단 한 번도 팔리지 않은 비운의 상품은 무엇일까?`
- 위 질문을 inner join을 이용해서는 찾을 수 없다
- 이 문제를 해결하기 위해 outer join을 사용한다
  - outer join을 사용하면 한쪽 테이블에만 존재하는 데이터도 결과에 포함 시킬 수 있다
- 실무에서는 left join이 right join보다 훨씬 더 많이 사용된다
  - 보통 분석의 기준이 되는 테이블을 from절에 먼저 쓰고, 필요한 정보를 담은 다른 테이블들을 left join 으로 하나씩 붙여나가는 방식으로 쿼리를 작성하는 것이 더 직관적이기 때문이다. right join은 테이블의 순서를 바꾸면 언제나 left join으로 동일하게 표현할 수 있다

### 외부 조인(Outer join)인 이유

- 내부 조인(Inner join)은 교집합 안(Inner)을 의미한다
- 외부 조인은 교집합 밖(Outer)의 영역을 포함한다는 의미이다

### 문법

- `left outer join -> left join`
  - left join 구문의 왼쪽(FROM절)에 있는 테이블이 기준이 된다
  - 일단 왼쪽 테이블의 모든 데이터를 결과에 포함 시킨다
  - 그 다음, ON 조건에 맞는 데이터를 오른쪽 테이블에서 찾아 옆에 붙여준다
  - 만약 오른쪽 테이블에 짝이 맞는 데이터가 없다면, 그 자리는 NULL 값으로 채워진다
- `right outer join -> right join`
  - RIGHT JOIN 구문의 오른쪽(join 절)에 있는 테이블이 기준이 된다
  - 일단 오른쪽 테이블의 모든 데이터를 결과에 포함시킨다
  - 그 다음, ON 조건에 맞는 데이터를 왼쪽 테이블에서 찾아 붙인다
  - 마찬가지로 왼쪽 테이블에 짝이 맞는 데이터가 없다면, 그 자리는 NULL로 채워진다
- outer는 생략해서 사용할수 있으며, 생략하는 것을 권장한다

## 조인의 특징

- 두 테이블을 조인할 때 어떤 경우에는 행이 더 늘어나고 어떤 경우에는 행이 늘어나지 않고 그대로인 경우가 있다
  - 이 부분은 데이터베이스를 다루는 데 있어 정말 중요하므로 반드시 제대로 이해해야 한다
- 부모/ 자식 테이블
  - 부모 테이블 (Parent Table): PK를 가지고 있는 테이블. (`users` ,`products`)
  - 자식 테이블 (Child Table): FK를 통해 부모 테이블을 참조하는 테이블. (`orders`)

### 자식-> 부모 조인 (FK->PK 참조): 기준 테이블(FROM절)행 개수가 늘어나지 않는다

- `orders` 테이블을 기준으로 `users` 테이블을 조인하는 경우다
- 자식 테이블(`orders` )의 각 주문 정보는 반드시 단 한 명의 부모(`users` )하고만 연결된다. 주문 하나가 여러 고객의 것일 수는 없기 때문이다. 
- 따라서 기준 테이블인 `orders` 의 행 개수가 그대로 유지된다. PK는 유일한 하나의 값만 저장된다. 
- 따라서 PK 방향으로 참조하는 경우 행 개수가 늘어나지 않는다.

### 부모-> 자식 조인 (PK->FK 참조): 기준 테이블(FROM절)의 행 개수가 늘어날 수 있다

- `users` 테이블을 기준으로 `orders` 테이블을 조인하는 경우다.
- 부모 테이블(`users` )의 한 고객은 여러 명의 자식(여러 건의 `orders` )을 가질 수 있다. 
- 이 경우, 한 고객의 정보를 여러 주문 정보에 각각 매칭시켜야 하므로, 고객 정보 행이 주문 건수만큼 복제되어 전체 행의 수가 늘어난다.
- FK는 같은 값을 여러개 저장할 수 있다. 
- 따라서 FK 방향으로 참조하는 경우 행 개수가 늘어날 수 있다.

### 실무에서 이것이 왜 중요할까?

- 이 원리를 모르면 데이터를 잘못 분석하게 될 위험이 크다. 예를 들어, 모든 고객과 그들의 주문 정보를 보기 위해 `FROM
users JOIN orders` 를 수행했다고 하자.
  - 이 결과에서 고객 수를 세기 위해 `COUNT(u.user_id)` 를 실행하면 어떻게 될까? 전체 고객 수인 6이 나올까? 아니다. 주문을 여러 번 한 고객이 중복 계산되므로, 전체 주문 수인 7이 나온다.
  - 이처럼 조인으로 인해 데이터가 어떻게 변하는지 정확히 이해해야만, 합계(`SUM` ), 평균(`AVG` ), 개수(`COUNT` ) 같은 집계 함수를 올바르게 사용하고 원하는 분석 결과를 정확하게 도출할 수 있다.
  - 쿼리를 작성하기 전에 항상 어떤 테이블을 기준으로 삼을지, 그리고 조인으로 인해 행 수가 증가하는 상황인지 아닌지, 먼저 생각하는 습관을 들이는 것이 중요하다.

### 실무에서 많이 사용하는 insert into .. select 문

```sql
create table product_options (
	option_id bigint auto_increment,
	product_name varchar(255) not null,
	size varchar(10) not null,
	color varchar(10) not null,
	primary key (option_id)
);

insert into product_options (product_name , size , color)
select 
	concat('기본티셔츠-', c.color, '-', s.size) as product_name,
	s.size,
	c.color
from 
	colors c
cross join sizes s;
```

- 초기 데이터 삽입시 많이 사용한다
- cross join은 위험하니 조심해서 사용해야 한다(100만건 x 10만건 = 1000억건)