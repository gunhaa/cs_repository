# 트랜잭션

- 트랜잭션은 논리적으로 쪼개질 수 없는 하나 이상의 데이터베이스 작업 묶음(Unit of work)을 의미한다
- 트랜잭션은 All or Nothing이라는 원칙을 제공한다
  - 트랜잭션으로 묶인 작업은 모두 다 성공해야만 그 결과를 실제 데이터베이스에 영구 반영한다
  - 만약 작업 그룹내에서 단 하나의 작업이라도 실패하면 그 전에 성공했던 모든 작업을 전부 없던일로 되돌린다
  - Atomic 연산이라고도 불린다

## 트랜잭션이 필요한 이유

- 데이터 일관성을 위협하는 것은 잘못된 상태뿐이 아니다
  - 데이터를 변경하는 행위에서 문제가 생길수도 있다
- 트랜잭션이 없다면 주문하기라는 로직을 실행하기 어렵다
  - 주문하기는 단순해보이지만 2가지 작업을 순차적으로 처리해야한다
    1. 작업 1: orders 테이블에 새로운 주문 정보 INSERT
    2. 작업 2. products 테이블에서 주문된 상품의 재고 UPDATE하여 1만큼 줄인다
  - 이 두 작업은 논리적으로 절대 쪼개질 수 없는 하나의 묶음이다
    - 두 작업을 하나로 묶을 수 있는 트랜잭션이 없다면 일관성이 깨지는 문제가 발생할 수 있다

## 트랜잭션의 ACID 속성

- 데이터베이스 시스템 이론에서는 트랜잭션이 신뢰성을 갖추도록 반드시 지켜야할 4가지 속성을 ACID라고 부른다
- ACID는 모든 RDBS의 근간을 이루는 중요한 개념이다

### Atomic 원자성

- 트랜잭션은 하나의 원자처럼 더 이상 쪼갤 수 없는 논리적 단위이며, 전부 성공하거나 실패한다

### Consistency 일관성

- 트랜잭션이 성공하면, Database는 항상 일관된(valid) 상태를 유지해야한다

### Isolation 격리성

- 하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 겨로가에 끼어들어 간섭할 수 없다
- 격리성이 없다면 로직이 완료되지 않은 중간 상태를 볼 수 있다(이를 Dirty read라고 한다)

### Durability 지속성

- 성공적으로 완료되어 COMMIT된 트랜잭션 결과는 시스템 장애가 발생하더라도 영구적으로 보존된다


## 트랜잭션 격리 수준

- 트랜잭션 격리 수준을 위해서는 데이터 정합성vs동시성/성능의 트레이드 오프를 이해 해야한다
  
### 동시성 문제

- 격리 수준이 낮을 때 발생할 수 있는 문제들이다
  1. 더티 리드 Dirty Read
    - 한 트랜잭션이 아직 COMMIT하지 않은 수정 중인 데이터를 다른 트랜잭션이 읽는 것
  2. 반복 불가능 읽기 Non Repetable Read
    - 한 트랜잭션 내에서 똑같은 SELECT쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 값을 수정하고 COMMIT해서 두 쿼리의 결과가 다르게 나오는 현상
    - 레코드의 재고가 10 -> 9로 변경
  3. 유령 읽기 Phantom Read
    - 한 트랜잭션 내에서 특정 범위의 데이터를 두번 읽었는데, 첫 번째 조회에서는 없었던 새로운 행이 두 번째 조회에서 나타나는 현상
    - 다른 트랜잭션이 새로운 행을 INSERT하고 COMMIT했기에 발생한다

### 4가지 표준 격리 수준

- SQL표준에 따른 4가지 격리 수준은 다음과 같다

| 격리 수준          | Dirty Read | Non-Repeatable Read | Phantom Read   |
|---------------------|------------|---------------------|----------------|
| READ UNCOMMITTED    | 발생       | 발생                | 발생           |
| READ COMMITTED      | 방지       | 발생                | 발생           |
| REPEATABLE READ     | 방지       | 방지                | 발생(일부 방지*) |
| SERIALIZABLE        | 방지       | 방지                | 방지           |

- READ UNCOMMITTED: 거의 아무것도 막아주지 않는, 가장 낮은 수준. 정합성 이슈가 많아 거의 사용되지 않는다.
- READ COMMITTED: 더티 리드를 방지한다. 즉, COMMIT 된 데이터만 읽을 수 있다. 오라클, SQL Server 등 많은 데이터베이스의 기본 격리 수준이다.
- REPEATABLE READ: 한 트랜잭션 안에서는 데이터의 일관된 조회를 보장해 준다. MySQL의 InnoDB 스토리지 엔진이 사용하는 기본 격리 수준이다
- SERIALIZABLE: 가장 엄격한 수준. 동시성 문제를 완벽하게 차단하지만, 트랜잭션을 거의 순서대로 실행시켜 동시 처리 성능이 가장 낮다

#### MySQL InnoDB 특징

- SQL표준에 따르면 REPEATABLE READ 수준에서는 팬텀 리드가 발생할 수 있다고 정의되지만 MySQL에서는 다르다
- MySQL의 InnoDB 엔진은 MVCC와 Gap Lock을 사용해 REPEATABLE READ에서도 대부분의 팬텀 리드가 발생하는 것을 막아준다
- InnoDB의 REPEATABLE READ는 표준 SEREIALIZABLE에 가까운 격리성을 제공한다

### 실무의 격리수준

> 특별한 이유가 없다면 MySQL의 기본 격리 수준인 REPEATABLE READ를 그대로 사용하는 것이 좋다

#### READ COMMITED로 낮추는 것을 고려하는 경우

- 성능과 동시성 확보가 매우 중요하고, 약간의 데이터 비일관성을 감수할 수 있다면 READ COMMITTED를 선택할 수 있다
- 많은 웹 애플레키이션은 '하나의 요청 = 하나의 짧은 트랜잭션'으로 동작하는 경우가 대부분이다
  - 하나의 사용자가 상품 목록을 조회하면 서버는 DB에서 상품 목록을 조회해서 반환하고 트랜잭션을 종료한다
  - 이런 환경에서는 트랜잭션 하나에서 SELECT쿼리를 여러 번 실행할 일이 거의 없으므로 Non-Repeatable Read가 발생할 확률 자체가 낮다
- READ COMMITED를 사용하면 불필요한 락을 사용하지 않게되어 기다리는 시간이 줄어든다
- 결과적으로 데이터베이스의 전체적인 처리량(Throughput)이 향상될 수 있다
- Oracle, PostgreSQL, SQL Server와 같은 다른 인기있는 데이터베이스들이 READ COMMITTED를 기본값으로 채택한 이유이기도 하다
- 성능 향상은 어플리케이션 성격에 따라 다르지만, 업데이트와 입력이 빈번하게 발생하는 높은 동시성 환경에서는 대략 10-30% 수준의 처리량 향상을 기대해 볼 수 있으며, 경우에 따라서 그 이상도 가능하다
  - 물론 이는 일반적인 수치이며, 실제로는 쿼리 패턴과 데이터 경쟁 정도에 따라 크게 달라질 수 있다

#### SERIALIZE로 높이는 것을 고려하는 경우

> 동시성이 크게 떨어져 최대한 사용하지 않고, 최후의 수단으로 사용해야 한다

- 데이터 정합성이 극도로 중요해서 예외가 허용이 안될 떄 사용한다
- 동시성이 현저히 떨어져서 시스템 전체 성능에 병목 될 가능성이 매우 높다
- 이에 대한 대안으로는
  1. 격리 수준을 무조건 높이기보다는 SELECT ... FOR UPDATE와 같은 비관적 락을 사용
  2. 버전 번호를 사용하는 낙관적 락을 사용
