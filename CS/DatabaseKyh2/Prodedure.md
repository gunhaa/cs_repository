# 프로시저, 함수, 트리거

- 문제상황
- "우리 쇼핑몰에서 새로운 회원이 가입할 때, 시스템은 다음과 같은 여러 작업을 순서대로 처리해야 한다."
  1. users 테이블에 새로운 고객 정보를 INSERT 한다
  2. user_profiles 테이블에 고객의 상세 프로필 정보를 INSERT 한다
  3. coupons 테이블에 신규 가입 축하 쿠폰을 INSERT 한다
  4. logs 테이블에 신규 회원이 가입했다는 기록을 INSERT 한다
- 이 4개의 SQL 문 묶음을 '회원가입'이라는 하나의 비즈니스 로직으로 구성한다
  - 이 로직을 애플리케이션에 둘 수도 있지만, 데이터 베이스 안에 저장해두고 `회원가입_처리('네이트', ...)`같이 간단하게 호출 할 수 없을까?
  - 이 요구사항을 해결하기 위한 기능이 저장 프로시저(Stored Procedure), 저장 함수(Stored Function), 트리거(Trigger)이다
  - 이들은 데이터베이스 내에 저장되어 실행되는 작은 프로그램 조각들이다

## 저장 프로시저 Stroed Procedure

1. 정의: 이름이 부여된 일련의 SQL 작업 묶음
2. 특징: 파라미터를 받아 로직을 처리할 수 있고, IF문이나 LOOP문 같은 제어문도 사용할 수 있다. 여러개의 INSERT, UPDATE, DELETE 작업을 포함하는 복잡한 비즈니스 로직을 하나의 단위로 처리하는데 사용된다
3. 호출 방식: CALL 프로시저이름(파라미터1, 파라미터2); 와 같이 CALL 명령어로 독립적으로 호출된다

## 저장 함수 Stored Function

1. 정의: 특정 계산을 수행하고 반드시 '하나의 값'을 반환하는 프로그램
2. 특징: 프로시저와 달리 하나의 값을 반환(RETURN) 해야하는 점이 다르다. 이 특징 때문에 SUM()이나 COUNT()같은 내장 함수처럼 일반적인 SELECT 쿼리문 안에서 값의 일부로 사용될 수 있다
3. 사용 방식: SELECT name, 나의함수(컬럼명) FROM 테이블; 처럼 쿼리의 일부로 사용된다

## 트리거 Trigger

1. 정의: 특정 테이블에 특정 이벤트가 발생했을떄 자동으로 실행되도록 약속된 프로그램
2. 특징: 개발자가 직접 호출하는 것이 아니라, 특정 조건이 만족되면 데이터베이스에 의해 Trigger되서 실행된다. 이벤트란 INSERT, UPDATE, DELETE 같은 데이터 변경 작업을 의미한다
3. 사용 방식: orders 테이블에 새로운 주문(INSERT)가 들어올 떄마다 자동으로 shipment 테이블에 새로운 배송 준비 데이터를 생성하거나, logs 테이블에 Audit기록을 남기는 용도로 사용될 수 있다

## 요즘에는 사용되지 않는 이유 1

1. 성능: 과거 애플리케이션 서버의 성능이 좋지 않고 네트워크 속도가 느렸던 시절, 여러 개의 SQL을 네트워크를 통해 주고 받는 것보다 데이터 베이스 안에 로직을 넣어두고 한 번만 호출하는 것이 더 효율적이어서 사용되었다
2. 코드 재사용과 중앙화: 여러 종류의 어플리케이션(java, python, 엑셀 ...)이 모두 데이터베이스 로직을 사용해야된다면 데이터베이스에 중앙화해두면 모두 일관된 로직을 사용할 수 있다
3. 보안: 사용자에게 테이블 수정 권한을 주지않고, 특정 프로시저를 호출할 수 있는 EXECUTE 권한만 부여한다면 더 안전한 방식으로 데이터를 변경하도록 강제할 수 있다

## 요즘에는 사용되지 않는 이유 2

1. 유지보수의 어려움
   - Database에 로직이 들어가면 시스템 로직이 애플리케이션과 데이터베이스 양쪽에 흩어지게 된다
     - 비즈니스 규칙을 변경해야할때 개발자가 혼란에 빠지게된다
     - Git으로 변경 이력 관리가 안되며, 버전 관리 흐름에 통합하기가 훨씬 더 까다롭다
     - 코드 리뷰, 테스트, 배포 과정이 복잡해지고 관리 포인트가 늘어난다
2. 성능 및 확장성 문제
    - 과거에는 Database server가 가장 성능이 좋은 '가장 비싼 컴퓨터'였기에, Database server에 일을 몰아주는게 합리적이였지만 지금은 아니다
    - Database bottleneck
      - Database는 cpu 입출력에 애플리케이션 로직까지 처리하느라 과부하가 걸려 병목(bottleneck)되게 쉬워진다
    - 확장성
       - 현대 웹 서비스는 수평적확장에 유리하도록 설계된다(애플리케이션 인스턴스 추가)
         - 즉, 사용자가 몰리게되면 서버를 여러 대 증설하여 부하를 분산시킨다
       - 하지만 Database server는 수평적 확장이 어렵고, 성능을 높이기 위해서는 더 비싼 장비로 교체하는 수직적확장에 의존해야하는데, 이는 비용이 기하급수적으로 비싸고 그 마저도 한계가 명확하다
         - 샤딩을 사용하면 수평확장이 가능하지만 관리와 운영이 어렵다
       - 즉, 현대 아키텍처의 기본 원칙은 값싸고 쉽게 확장할 수 있는 애플리케이션 서버가 비즈니스 로직을 담당하고, 비싸고 확장하기 어려운 데이터베이스는 데이터 저장 및 관리에만 집중하도록 역할을 분리하는 것이다
3. 특정 데이터베이스에 대한 종속성
    - 저장 프로시저, 함수, 트리거를 작성하는데 사용되는 절차적 SQL언어는 제조사마다 다르다
    - Oracle로 작성 후, 몇 년 후 비용문제로 MySQL이나 다른 오픈소스 데이터베이스로 이전하기 위해서는 새롭게 작성해야한다
      - 이것은 데이터베이스 이전을 불가능하게 만두는 '기술적 부채'이자 '벤더 종속(Vendor Lock-in)'의 원인이 된다

## 현대의 대안: 명확한 역할 분리

- 현대 애플리케이션의 대안은 명확한 역할의 분리이다
  - 애플리케이션 계층: 비즈니스 로직, 데이터 가공, 조건 처리, 절차 제어 등 모든 지능적인 처리를 담당한다. 데이터 베이스와는 표준 SQL을 통해 소통한다
  - 데이터베이스 계층: 오직 데이터의 저장, 조회, 무결성 보장(제약 조건), 트랜잭션 관리라는 데이터 본연의 역할에만 충실한다
- 이런 접근이 시스템을 유연하고, 확장 가능하며, 유지보수하기 쉽게 만든다