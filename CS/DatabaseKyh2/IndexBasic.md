# Index

## Index가 필요한 이유

```sql
SELECT * FROM items WHERE item_name = '게이밍 노트북';
```

- 데이터가 많아지면 잘되던 쿼리도 느려지기 시작한다
  - 데이터가 최소 몇십만~몇백만이 되어야 한다

### Full table scan

- 인덱스가 없는 테이블에서 특정 데이터를 찾는 과정은 100만 페이지짜리 거대한 책에서 특정 단어를 찾기위해 책 첫 페이지부터 마지막 페이지까지 한 장 한 장 넘겨보는 것과 같다
- Database에 item_name컬럼에 '게이밍 노트북'이라는 값이 어디에 있는지 알 수 있는 아무런 '힌트'가 없다
  - 그래서 Database는 가장 무식하고 정직한 방법을 선택한다
    - 바로 items 테이블 전체를 디스크에서 메모리로 읽은 후, 첫 번째 레코드부터 마지막 100만 번째 레코드까지 차례대로 item_name 컬럼의 값을 비교하는 것이다
- 이런 작업 방식을 Full table scan이라고 부른다
  - 최선의 경우: 우리가 찾는 데이터가 우연히 첫 번째 행에 있다면 한 번의 비교만으로 끝난다
  - 최악의 경우: 우리가 찾는 데이터가 맨 마지막에 있거나, 아예 존재하지 않는다면 100만 번의 비교를 모두 수행해야만 결과물을 알 수 있다
- 풀 테이블 스캔은 O(n)의 수행시간이 걸린다

### 데이터 양에 따른 성능 저하

- 데이터 양에 따른 정확한 응답 시간을 예측하는 것은 거의 불가능하다
- 왜냐하면 응답 시간은 데이터베이스의 서버의 사양(CPU, Memory, Disk I/O성능), 환경설정, 데이터 레코드의 크기, 시스템의 현재 부하 등 수 많은 변수에 따라 크게 달라지기 때문이다
- 하지만 일반적인 기업용 서버 환경(SSD 디스크 기반), 한 행당 1KB의 데이터를 가진 테이블을 기준으로 대략적인 예상 응답 시간을 정리하면 아래와 같다

| 데이터 건수 | 총 데이터 크기 (행당 1KB 가정) | 예상 응답시간                     | 비고                                                                                    |
| ----------- | ------------------------------ | --------------------------------- | --------------------------------------------------------------------------------------- |
| 100만 건    | 약 1GB                         | 수 초 (예: 0.2초 ~ 3초)           | 디스크 I/O 속도에 따라 좌우되며, 메모리(버퍼 캐시)에 데이터가 일부라도 있으면 더 빨라짐 |
| 1,000만 건  | 약 10GB                        | 수 초 ~ 1분 내외 (예: 2초 ~ 30초) | 본격적으로 디스크 I/O 병목이 발생하기 시작하는 구간                                     |
| 1억 건      | 약 100GB                       | 수십 초 이상 (예: 20초 ~ 5분)     | 다른 작업과 경합이 발생할 경우 응답시간은 예측하기 어려울 정도로 길어질 수 있음         |

- 이 표는 단순 참고용이며, 실제 환경에서는 몇 배 이상 차이날 수 있다
- 실제로는 수 많은 요청을 동시에 처리한다
  - 10명의 사용자가 동시에 요청하면 풀 테이블 스캔도 10개가 동시에 발생할 수 있다
  - 이 경우 성능은 훨씬 더 느려진다

#### 페이지 로딩 속도와 사용자

- 페이지 로딩 속도에 관한 다양한 논문들이 있는데 대략 정리하면 다음과 같다
  - 모바일 페이지 로딩 속도가 1초에서 3초로 늘어나면 이탈률 +32%
  - 모바일 페이지 로딩속도가 1초에서 5초로 늘어나면 이탈률 +90%
- 웹 서비스는 최소한 3초이내, 이상적으로는 1-2초 이내의 빠른 로딩 속도를 목표로 해야한다

#### Full table scan에 대한 결론

- Full table scan은 비용이 매우 높은 작업이다
  - 서비스의 핵심 기능에서 풀 테이블 스캔이 발생하지 않도록 설계하는 것은 필수이다
- 해결 방법
  1. 인덱스 활용: WHERE절에 자주 사용되는 검색 조건 컬럼에는 Index를 생성하여 풀 테이블 스캔을 방지하는 것이 가장 기본적인 해결책이다
  2. 실행 계획 확인: 쿼리 실행 전 Execution Plan을 확인하여 의도치 않은 풀테이블 스캔이 발생하는지 반드시 점검 해야한다
  3. 작업 시간 분리: 대용량 데이터에 대한 전체 스캔이 불가피한 통계/배치 작업이라면, 서비스 이용자가 적은 새벽 시간에 실행하는 것을 권장한다

## Index란?

- Database의 Index는 책의 '찾아보기'와 정확히 동일한 역할을 한다
- 인덱스는 특정 컬럼(들)의 데이터를 기반으로 생성되는, 원본 테이블과는 별개의 특수한 자료구조이다
  - 인덱스는 지정된 컬럼의 값과, 해당 값을 가진 실제 데이터 행의 위치(ROWID/포인터/ 등 데이터베이스 인덱스의 종류에 따라 다름)를 한 쌍으로 저장한다
  - 가장 중요한 것은 인덱스 내부의 데이터는 항상 정렬된 상태를 유지한다는 점이다
- 정렬된 상태를 이용해 Database가 원하는 데이터를 빠르게 찾을 수 있다(gt,lt 사용)

### 실제 인덱스의 구현

- 특정 Database 시스템에 종속된 인덱스는 여러가지 종류가있다
- MySQL의 경우 클러스터 인덱스와 보조 인덱스라는 2가지 종류의 인덱스를 제공한다
  - 클리스터 인덱스(Clustered Index): PK를 기반으로 만드는 인덱스이며, 원본 데이터 자체를 인덱스에 함께 보관해서 원본 데이터를 매우 빠르게 찾을 수 있다
  - 보조 인덱스(Secondary Index): 원본 데이터의 PK 값을 함께 보관하며, 이 PK 값으로 클러스터 인덱스를 통해 원하는 데이터를 조회한다
- 인덱스의 종류에 따라 내부 동작 방식은 다양하지만, 결국 핵심 목적은 데이터 검색 속도를 향상시키고 쿼리 성능을 최적화하는 것이다

### Index 자료구조

- B+ 트리 구조로 저장된다
  - Balanced Tree의 일종으로, 모든 leaf node가 같은 깊이에 존재한다
  - 이진 탐색 트리가 아니라, 하나의 노드가 여러 키와 자식을 가질 수 있는 다분기 트리(M-ary Tree) 구조다
    - 이진 탐색 트리의 경우 한 노드가 한개의 데이터만 가지고 있어, 데이터를 검색할 때 여러 노드를 방문해야 한다면 그 만큼 디스크에서 많은 블록을 읽어야한다
      - 자식 노드로 내려갈 때마다 새로운 블록을 디스크에서 읽어야 하기 때문에, 트리 높이가 곧 디스크 I/O 횟수와 직결된다
    - 반면 B 트리의 경우 하나의 노드가 여러 개의 자식 노드를 가질 수 있고, 더 많은 데이터를 저장할 수 있도록 설계되었다
      - 이는 디스크에서 한 번 데이터를 읽을 때 더 많은 정보를 가져올 수 있게하여 디스크 I/O횟수를 획기적으로 줄여준다
      - 이를 이용해 B-트리는 disk I/O를 최소화하며 대용량 데이터에서 효율적인 검색 성능을 제공한다
- 트리 자료구조에서는 각 노드가 자식 노드의 위치를 가리키는 포인터를 가지고 있다
  - 메모리 안에서 포인터를 따라가면 그냥 접근하면 되지만, 디스크에 저장된 경우 포인터가 가리키는 위치(블록)를 실제로 읽어와야 한다.
  - 즉, 노드 하나를 방문할 때마다 디스크에서 블록을 로드해야 하는 상황이 생긴다.
  - 그래서 이진 탐색 트리는 노드당 데이터가 하나이므로, 검색할 때마다 디스크에서 여러 블록을 읽어야 한다.
  - 반대로 B+ 트리는 노드당 여러 키와 자식을 가지고 있어서, 한 번 블록을 읽을 때 더 많은 데이터를 확인할 수 있고 트리 높이도 낮아 디스크 I/O가 줄어든다.

#### 이진 탐색 트리

- 이진 탐색 트리의 빅오 - O(log n)
  - 2개의 데이터 2로 1번 나누기, `log₂(2)=1`
  - 4개의 데이터 2로 2번 나누기, `log₂(4)=2`
  - 8개의 데이터 2로 3번 나누기, `log₂(8)=3`
  - 16개의 데이터 2로 4번 나누기, `log₂(16)=4`
  - 32개의 데이터 2로 5번 나누기, `log₂(32)=5`
  - 64개의 데이터 2로 6번 나누기, `log₂(64)=6`
  - ...
  - 1024개의 데이터 2로 10번 나누기, `log₂(1024)=10`
  - 16,384개의 데이터 2로 14번 나누기, `log₂ (16384)=14`
  - 65,536개의 데이터 2로 16번 나누기, `log₂ (65536)=16`
  - 131,072개의 데이터 2로 17번 나누기, `log₂ (131072)=17`
  - 1,000,000개의 데이터 2로 약 20번 나누기, `log₂ (1,000,000)≈19.93`
  - 10,000,000개의 데이터 2로 약 24번 나누기, `log₂ (10,000,000)≈23.22`
  - 100,000,000개의 데이터 2로 약 27번 나누기, `log₂ (100,000,000)≈26.57`
  - 1024개의 데이터를 단 10번의 계산으로 원하는 결과를 찾을 수 있다.
  - 1억개의 데이터가 있어도 약 27번의 계산으로 원하는 결과를 찾을 수 있다
- 이진 탐색 트리의 핵심은 입력 순서가 아닌, 데이터 값을 기준으로 정렬해서 보관한다는 점이다
  - 정렬해서 보관했기 때문에 정렬된 순서로 데이터를 차례로 조회할 수 있다
- 트리는 일반적으로 O(log n)이지만 균형이 맞지않으면 최악의 경우 O(n)의 성능이 나온다
  - O(n)은 10개의 데이터가 있다면 최악의 경우 10번의 탐색이 필요하다는 것이다
  - 이를 해결하기 위한 트리의 개선 방법은 트리의 균형을 동적으로 맞추는 것이다
    - 이렇게 균형을 유지하는 트리를 Balanced Tree라고 부른다
    - 대부분의 관계형 데이터베이스는 인덱스에 Balanced tree를 사용해서 균형을 유지한다
    - 따라서 최악의 경우에도 O(log n)의 성능을 제공한다

### MySQL 자동 생성 Index

- PK, FK, Unique의 경우 MySQL에서 자동으로 Index를 생성한다

#### Unique 제약조건에 인덱스를 자동생성하는 이유

- Unique 제약조건은 컬럼 내 데이터의 유일성을 보장해야한다
- 새로운 데이터를 insert, update할 때마다, 입력하는 값이 테이블에 이미 존재하는지 확인해야 한다
- 만약 인덱스가 없다면 이 중복 검사를 위해 매번 테이블 풀 스캔이 발생하여 쓰기 성능이 크게 저하될 것이다


### 인덱스가 정말 사용되는지 확인하는 법 (EXPLAIN)

- Database에는 쿼리를 어떤 방식으로 최적화해서 실행할지 계획하는 기능이 있다
  - 이것을 쿼리 옵티마이저라고 한다
  - 인덱스를 만들었다고, Database가 모든 SELECT문에 항상 인덱스를 사용하지 않는다
  - 데이터의 분포나 쿼리의 형태에 따라, Database 옵티마이저는 인덱스를 사용하는 것보다 풀 테이블 스캔이 더 빠르겠다고 판단할 수도 있다
  - 추가로 사용할 수 있는 인덱스가 여러개 있다면 어떤 인덱스를 사용할지도 선택한다
  - 실제로 확인해보기 위해선 EXPLAIN이라는 명령어를 쿼리문 앞에 붙여보면 된다

```sql
explain select * from items where item_name = '게이밍 노트북';
```
- [실행 결과]
  | id  | type | key  | rows | filtered | Extra        |
  |-----|------|------|------|----------|--------------|
  | 1   | ALL  | NULL | 25   | 10.00    | Using where  |
- type
  - 가장 중요한 부분이다
  - type은 Database가 테이블에 어떻게 접근할지를 나타낸다
  - ALL은 Full table scan을 의미한다
  - items 테이블의 처음부터 끝까지 모든 데이터를 하나씩 다 읽어서 조건에 맞는 데이터를 찾는다는 뜻이다
  - 데이터가 적을땐 문제가 없지만, 수백만건의 데이터에서는 성능저하의 주범이된다
  - 인덱스를 제대로 사용했다면 ref, range등 다른 값이 표시된다
    - ref는 = 조건이나 join에서 인덱스를 사용했다는 의미이다
    - range는 범위검색(between, >, <, >= ..)에서 인덱스를 사용했다는 의미이다
- key
  - 쿼리를 실행할 때 사용한 인덱스를 보여준다
  - NULL은 인덱스를 사용하지 못했다고 알려주는 것이다
- rows
  - 옵티마이저가 쿼리를 처리하기 위해 탐색할 것으로 예측하는 행의 수
  - 이 값이 적을 수록 효율적인 쿼리라 할 수 있다
- filtered
  - 10.00%라는 의미이다
  - 최종적으로 남을것으로 예측되는 행의 비율
- extra
  - 데이터를 가져온 후에 where절의 조건을 사용해 필터링 작업을 수행했다는 의미이다
  - 인덱스가 없으니 모든 데이터를 가져와서 그 후에 조건이 맞는지 일일히 검색하는 비효율적인 방식으로 일하고 있음을 보여준다

## 인덱스가 사용되는 곳

1. 동등 비교(=)
2. 범위 검색(BETWEEN, >, <, <=, LIKE 등)
3. ORDER BY를 통한 정렬 작업

### 인덱스와 동등 비교

```sql
create index idx_items_item_name on items(item_name);
show index from items;
explain select * from items where item_name = '게이밍 노트북';
```
- [실행 결과]
  | id  | type | possible_keys       | key                | rows | filtered | Extra |
  |-----|------|-------------------|------------------|------|----------|-------|
  | 1   | ref  | idx_items_item_name | idx_items_item_name | 1    | 100.00   | NULL  |
- type: ref
  - 인덱스를 사용해 동등 비교조건으로 데이터를 찾았다는 의미이다
- key: idx_items_item_name
  - 이전에는 NULL이었지만 생성한 인덱스의 이름이 명확하게 표시된다
  - 이것은 옵티마이저가 인덱스를 사용했음을 보여주는 증거다
- filltered
  - 인덱스를 통해서 찾은 1개의 행을 100% 선택한다는 뜻이다
- rows
  - 인덱스가 없을 때는 전체 행의 수인 25를 예측했지만 이제는 1개의 행만 읽으면 된다고 예측한다
- Extra
  - 이전의 Using where이 사라졌다. 이는 인덱스 단계에서 이미 모든 검색 조건이 충족되었기 떄문에, 데이터를 가져온 후 별도의 필터링 작업이 필요 없었다는 것을 의미한다
- item_name 컬럼에 인덱스를 생성하자 Database 옵티마이저는 풀 테이블 스캔이라는 비효율적인 방법을 버리고 인덱스를 사용해 단 하나의 행만 읽어오는 매우 효율적인 실행계획을 세웠다
  - 이것이 바로 인덱스를 사용하는 핵심 이유이다

### 인덱스와 범위 검색

```sql
select * from items where price between 50000 and 100000;
explain select * from items where price between 50000 and 100000;

create index idx_items_price on items(price);
explain select * from items where price between 50000 and 100000;
```

- [인덱스가 없을 때 실행계획]
  | id  | type | key  | rows | filtered | Extra       |
  |-----|------|------|------|----------|-------------|
  | 1   | ALL  | NULL | 25   | 11.11    | Using where |
- [인덱스 생성 후 실행계획]
  | id  | type  | key             | rows | filtered | Extra                   |
  |-----|-------|-----------------|------|----------|-------------------------|
  | 1   | range | idx_items_price | 5    | 100.00   | Using index condition   |
- type: range
  - Database가 인덱스를 사용해 특정 범위의 데이터를 스캔했음을 의미한다
    - idx_items_price 인덱스에서 price가 50000 이상인 지점을 찾은 뒤, 100000을 초과하는 지점이 나올 때까지만 순차적으로 인덱스를 읽었다는 뜻이다. 테이블 전체를 훑는 풀 테이블 스캔과 비교할 수 없이 효율적인 방식이다
- key
  - 쿼리 실행에 idx_items_price 인덱스가 사용되었음을 명확히 보여준다
- rows
  - 옵티마이저가 스캔할 것으로 예상되는 숫자가 5로 크게 줄었다
- filtered
  - 인덱스를 통해서 스캔한 5개의 행을 100% 선택한다는 뜻이다
- Extra
  - 인덱스 정보만으로 where 조건절을 최대한 필터링한 후, 조건을 만족하는 데이터의 전체 행만 가져왔다는 뜻이다

### 인덱스와 LIKE 범위 검색

- LIKE절에 인덱스를 사용하려면, 와일드카드(%)가 검색어 뒤쪽에 위치해야 한다
  - '게이밍%': 인덱스 사용 가능
  - '%게이밍': 인덱스 사용 불가
  - '%게이밍%': 인덱스 사용 불가
- %가 앞에 있으면 시작점이 불분명해져 정렬된 인덱스를 활용할 수 없기 때문이다
- 인덱스의 범위 검색(range)를 사용한다
  - 글자가 정렬되어 있기 때문이다
  - 처음 한 번만 찾고(이진 탐색의 원리를 사용하므로 매우 빨리 찾을 수 있다), 이후에는 별도의 탐색 과정 없이 연속해서 결과를 구할 수 있다

#### 전체 문자 검색 Full Text Search

- LIKE '%검색어%' 방식은 데이터가 많아질수록 성능이 심각하게 저하되어 실제 서비스에서는 사용하기 어렵다
- 이런 '내용 검색'또는 '포함 검색'문제를 해결하기 위해서는 Full-Text Search라는 특수한 기능을 제공한다
  - Full text search는 B-Tree 인덱스와는 달리 텍스트를 토큰 단위로 쪼개서 인덱싱하는 방식이다(Inverted Index 사용)
  - 이를 통해 텍스트 중간에 있는 단어도 매우 빠르게 검색할 수 있다
  - LIKE대신 MATCH ... AGAINST 구문을 사용하는 것이 해결 방법이다

## 인덱스와 정렬

- Database에서 정렬Order by 작업은 생각보다 비용이 많이 드는 무거운 작업 중 하나이다
  - 조건에 맞는 데이터를 모두 찾은 후, 그 결과를 서로 비교하면서 순서에 맞게 다시 정렬해야 하기 때문이다
  - 하지만 정렬된 인덱스를 활용해 이 작업을 개선 할 수 있다
- order by가 인덱스를 잘 활용하면 별도의 정렬 과정 없이 이미 정렬된 인덱스를 순서대로 읽기만 하면 되므로 매우 빠르게 동작한다
  - Database는 이 과정에서 filesort라는 별도의 정렬 작업을 생략할 수 있게 된다
    - filesort는 메모리나 디스크를 사용해 정렬하는 내부 프로세스를 의미한다
    - 최적화의 목표는 이 비효율적인 filesort를 피하는 것이다

```sql
EXPLAIN SELECT * FROM items
ORDER BY stock_quantity;
```
- [실행 결과]
  | id  | table | type | key  | rows | filtered | Extra        |
  |-----|-------|------|------|------|----------|--------------|
  | 1   | items | ALL  | NULL | 25   | 100.00   | Using filesort |
- Extra
  - Using filesort를 확인할 수 있다
  - 데이터를 모두 찾은 후 stock_quantity를 기준으로 정렬 작업이 추가된다

### 인덱스를 사용해 정렬까지 한 번에 처리하는 경우

- [실행 결과]
  | id  | type  | key             | rows | filtered | Extra                   |
  |-----|-------|-----------------|------|----------|-------------------------|
  | 1   | range | idx_items_price | 5    | 100.00   | Using index condition   |
- 가장 이상적인 상황은 where절의 조건과 order by절의 정렬 기준이 같은 경우이다
  - 인덱스 하나로 검색과 정렬을 모두 해결하는 경우가 가장 이상적이다
- Extra
  - 별도의 정렬 작업인 Using filesort가 없다
  - Database 옵티마이저는 idx_items_price가 이미 price순서대로 정렬되어 있다는 사실을 알고있다
    - 따라서 where 조건에 맞는 데이터를 찾기 위해 인덱스를 스캔하는 것만으로도 자연스럽게 price순서로 정렬된 결과를 얻을 수 있다
    - 즉, 별도의 정렬 작업을 할 필요가 전혀 없다는 것이다
- 인덱스를 쓰면 자동으로 정렬이 된다는것을 옵티마이저가 알고있는 것이 중요하다

#### 인덱스 역방향으로 조회하면 어떻게 될까?

```sql
explain select * from items where price between 50000 and 100000
order by price desc;
```
- [실행 결과]
  | id  | type  | key             | rows | filtered | Extra                                   |
  |-----|-------|-----------------|------|----------|-----------------------------------------|
  | 1   | range | idx_items_price | 5    | 100.00   | Using index condition; Backward index scan |

- 내림차순 정렬을 사용하면 filesort가 발생하지 않는다
  - 단일 컬럼 인덱스에서는 filesort없이 효율적인 처리가 가능하다
  - Database 옵티마이저는 인덱스를 거꾸로 읽는, 역방향 스캔이 가능하다
- Backward index scan
  - 옵티마이저가 idx_items_price 인덱스를 끝에서부터 앞으로, 즉 역순으로 스캔했음을 의미한다
  - 인덱스는 양방향 탐색이 가능하다
  - price가 높은 값부터 낮은 값으로 인덱스를 탐색하여 where 조건에 맞는 데이터를 찾는다
    - 이 과정에서 정렬 순서를 만족해서 filesort작업이 필요없다

#### 정방향 스캔과 역방향 스캔

- 정방향 인덱스 스캔이 역방향보다 미세하게 더 빠르다
  - 컴퓨터 하드웨어의 미리 읽기(prefetching)기능 때문이다
  - 컴퓨터는 데이터를 정방향으로 읽을 것을 예측하고, 다음 데이터를 준비해둔다
  - 이 방식으로 하드웨어가 최적화되어 있어 효율이 가장 높다
- 하지만 이 성능 차이는 미미해서 실무에서는 거의 무시해도 된다
  - order by에서 filesort를 피하는 것이 수백배는 더 중요하다

#### 문제 상황을 해결하기 위한 내림차순 인덱스(MySQL)

```sql
-- 생략하면 asc가 되고, 지정하면 desc로 인덱스를 만들 수 있다
create index idx_items_price on items(price desc);
```

#### 인덱스가 정렬에 가장 효율적인 경우

- `ORDER BY category asc, registered_date desc`
  - 여러 컬럼에 대해 서로 다른 정렬순서(오름차순,내림차순의 혼합)이 필요한 경우 인덱스의 진가가 발휘된다
  - 정렬순서에 맞춰 정확하게 생성 된 다중컬럼 인덱스(복합 인덱스)는 쿼리 성능을 극적으로 향상시킬 수 있다