# Index Advanced

## Optimizer와 인덱스 선택

- 컬럼에 인덱스를 생성하면 해당 컬럼을 조건으로 사용하는 where절의 성능이 향상될 것이라고 기대하기 쉽다
  - 하지만 항상 그렇지는 않다
  - Database의 Optimizer는 쿼리를 실행하기 전에 여러 실행 가능 방법을 평가하고 그 중 가장 비용이 적게 드는(가장 효율적인) 방법을 선택한다
  - 이 과정에서 Optimizer가 인덱스를 사용하는 것이 오히려 비효율적이라고 판단하면, 인덱스가 존재하더라도 포기하고 Full Table Scan을 선택할 수 있다
- 인덱스를 사용하면 검색 대상의 양은 줄어들지만, 테이블에 흩어진 데이터에 랜덤하게 접근해야 한다
- 풀테이블 스캔을 사용하면 items 테이블을 순서대로 쭉 읽으면 된다
- Database에서 인덱스를 통해 여러 행에 접근하는 것은 랜덤 I/O를 유발한다
- Table Full Scan의 경우 순차 I/O에 해당한다
- 조회할 데이터가 아주 많을 경우 여러 번의 랜덤 I/O를 수행하는 것보다 한 번의 순차 I/O가 더 빠를 수 있다

```sql
-- 예상 rows가 5이기에(5/25) 20%여서 인덱스를 사용한다
explain select * from items where price between 50000 and 100000;

-- 예상 rows가 25이기에(25/25) 비효율적이라고 판단해 풀 테이블 스캔을 사용한다
explain select * from items where price between 1000 and 200000;
```

- [실행 결과]
  | id | type | possible_keys | key | rows | filtered | Extra |
  |-----|-------|------------------|-----------------|------|----------|-----------------------|
  | 1 | range | idx_items_price | idx_items_price | 5 | 100.00 | Using index condition |

  | id  | type | possible_keys   | key  | rows | filtered | Extra       |
  | --- | ---- | --------------- | ---- | ---- | -------- | ----------- |
  | 1   | ALL  | idx_items_price | NULL | 25   | 76.00    | Using where |

### 인덱스 손익 분기점

- Optimizer가 인덱스 사용 여부를 결정하는 핵심기준은 바로 '손익분기점'이다
  - 인덱스를 통해 데이터를 읽는 비용이 테이블 전체를 직접 읽는 비용보다 높아지는 지점을 의미한다

```plaintext
인덱스를 사용하는 비용: 인덱스 탐색 비용+ 인덱스에서 찾은 주소로 테이블에 접근하는 비용(랜덤I/O)
풀 테이블 스캔 비용: 테이블 전체를 순차적으로 읽는 비용(순차 I/O)
```

- 일반적으로 전체 데이터의 20~25% 이상을 조회해야 하는 쿼리는 인덱스를 통해 각 행에 개별적으로 접근하는 것보다 테이블 전체를 순차 스캔하는 것이 더 효율적이다
- 즉 조회하려는 데이터의 양이 손익분기점을 넘어가면 옵티마이저는 인덱스 사용을 포기한다

#### 왜 랜덤 I/O가 더 느릴까?

- 랜덤 I/O가 순차 I/O보다 느린 이유는 데이터를 찾는 과정에서 발생하는 시간 때문이다
- 순차 I/O: 책을 1페이지부터 순서대로 읽기
  - 데이터가 저장된 위치를 한 번 찾으면, 그 이후로는 순서대로 쭉 읽기만 하면 된다
  - HDD의 경우 디스크의 헤드가 거의 움직이지 않고 연속된 데이터를 읽어오므로 작업이 매우 빠르고 효율적이다
  - SSD의 경우 "여기서부터 100개 읽어와" 라는 하나의 큰 명령으로 처리할 수 있다
- 랜덤 I/O: 책의 여러 페이지를 순서 없이 찾아 읽기
  - 5페이지를 읽은 후 200페이지를 읽고, 다시 45페이지를 읽는 방식이다
  - HDD의 경우 읽어야 할 데이터가 디스크의 여러곳에 흩어져있어, 데이터를 읽을 때마다 디스크 헤드가 물리적으로 이동해야한다
  - 이렇게 걸리는 시간(Seek time)이 추가되어 순차 I/O보다 느리다
  - SSD의 경우 100개의 작은 명령을 각각 처리해야 한다
    - 작은 명령을 여러 번 처리하는 것은 SD 컨트롤러에 더 많은 오버헤드를 준다

#### 데이터가 부족한 경우

- 데이터가 많이 없다면 옵티마이저는 풀 테이블 스캔을 선택할 가능성이 있다
- 테이블에 데이터가 몇 건 없다면 테이블 전체를 순차적으로 읽는 비용이 인덱스를 탐색하고 테이블에 접근하는 비용보다 훨씬 저렴하기 때문이다
  - 1000페이지짜리 두꺼운 책에서 index를 보고 원하는 페이지를 찾아가는 것이 빠르다
  - 하지만 3페이지짜리 얇은 소책자에서는 굳이 index를 확인할 필요 없이 1페이지부터 보는 것이 빠르다

## 커버링 인덱스

- 쿼리에 필요한 모든 컬럼을 포함하고 있는 인덱스
  - 커버링이라는 이름 그대로 인덱스 하나가 쿼리의 요구사항 전체를 '덮는다'는 의미
- 원본 테이블에 전혀 접근하지 않고 오직 인덱스만을 읽어서 쿼리를 처리한다
  - 비싼 랜덤 I/O작업을 제거하고 인덱스 순차I/O만으로 쿼리를 끝낸다

```sql
-- 새로운 인덱스를 생성해 커버링 인덱스 생성(price, item_name)
create index idx_items_price_name on items(price,item_name);
explain select item_id, price, item_name from items where price between 50000 and 100000;
```

- [실행 결과]
  | id | type | key | rows | filtered | Extra |
  |-----|-------|-----------------|------|----------|-----------------------------|
  | 1 | range | idx_items_price | 5 | 100.00 | Using where; Using index |
  - Extra: Using index
    - 쿼리에 필요한 모든 데이터를 인덱스에서만 읽어서 처리했음을 의미한다
    - 옵티마이저는 idx_items_price 인덱스만 스캔하여 price와 item_id를 모두 얻었고, 원본 items 테이블에는 전혀 접근할 필요가 없었다
  - Extra: Using where
    - 인덱스 내에서 where price between ...을 사용해 불필요한 데이터를 필터링 했음을 의미한다
    - Using index와 함께 사용되는 Using where는 테이블에 접근한 후 필터링하는 것이 아니라 인덱스 스캔 단계에서 효율적으로 필터링이 이루어졌음을 나타낸다
- 결론적으로 이 실행 계획은 커버링 인덱스를 활용해 테이블 접근을 피했고(Using index), 인덱스 내에서 where절의 조건으로 필터링(Using where)을 수행한 매우 효율적인 쿼리임을 보여준다

### 커버링 인덱스의 장단점

#### 장점

- 압도적인 SELECT성능 향상
  - 테이블 접근을 위한 랜덤 I/O를 제거하여 조회 성능을 극적으로 개선한다
- COUNT 쿼리 최적화
  - select count(\*)와 같은 쿼리에서 테이블 전체가 아닌, 크기가 훨씬 작은 인덱스만 스캔하여 결과를 빠르게 반환할 수 있다

#### 단점

- 저장 공간 증가
  - 인덱스는 원본 데이터와 별도의 저장공간을 차지한다
  - 인덱스에 포함되는 컬럼이 많아질수록 인덱스의 크기도 커진다
- 쓰기 성능 저하
  - INSERT/UPDATE/DELETE 작업 시, 테이블 데이터뿐만 아니라 인덱스도 함께 수정해야 한다
  - 인덱스가 많고 복잡할수록 쓰기 작업에 대한 부하가 커진다

### 커버링 인덱스 결론

- 커버링 인덱스는 만능 해결책이 아니며, 읽기 성능과 쓰기 성능 사이의 trade off를 고려해야 한다
  1. 조회가 매우 빈번하고, 쓰기 작업은 상대적으로 적은 테이블에 적용하는 것이 효과적이다
  2. SELECT 절에 조회하는 컬럼의 개수가 적을 때 유리하며, select \* 처럼 모든 컬럼을 조회하는 쿼리는 커버링 인덱스의 이점을 누리기 어렵다(모든 컬럼을 포함하는 인덱스를 만들 수는 있지만, 이는 사실상 테이블을 복제하는 것과 같아 매우 비효율적이다)
  3. 성능 저하가 발생하는 특정 쿼리를 튜닝하기 위한 마지막 수단인 경우가 많다

## 복합 인덱스/다중 컬럼 인덱스 Composite Index/Multi-column Index

> 실무에서 복합 인덱스를 잘못 이해해서 장애가 나는 경우가 흔하다<br>
> 이 원리를 잘 이해하고 쿼리를 작성않으면 큰 문제를 일으킬 수 있다

- 두 개 이상의 컬럼을 묶어서 하나의 인덱스로 만드는 것이다
- 컬럼의 순서가 중요하다
  - 인덱스를 어떤 컬럼 순서로 만드느냐에 따라 쿼리 성능이 하늘과 땅 차이로 달라질 수 있다

### 왜 컬럼 순서가 중요할까?

- 인덱스는 '국어 사전'과 같다
  - '첫 번째 글자'로 먼저 정렬된 후, 같은 첫 글자로 시작하는 단어들끼리 '두 번째 글자'로 다시 정렬된다
- items 테이블에 (category, price)의 복합 인덱스 생성시 내부적으로 다음과 같이 정렬 된다
  - category 기준으로 먼저 정렬한다
  - 같은 category 내에서는 price기준으로 다시 정렬한다
- [예시]
  | category | price | item_id |
  |------------|---------|---------|
  | 도서 | 18000 | 21 |
  | 도서 | 22000 | 25 |
  | 도서 | 28000 | 15 |
  | 도서 | 30000 | 4 |
  | 도서 | 35000 | 11 |
  | 생활용품 | 5000 | 16 |
  | 생활용품 | 15000 | 5 |
  | 생활용품 | 40000 | 9 |
  | 생활용품 | 60000 | 19 |
  | 전자기기 | 80000 | 3 |
  | ... | | |
- 위 테이블에서는 category로 검색이 효율적이다
- category와 price로 검색도 효율적이다
- price만으로 검색은 매우 비효율적이다
  - 이는 사전에서 앞 글자모르고 두 번째 글자로 찾는 것과 같다

### 인덱스 왼쪽 접두어 규칙(Index Left-Prefix Rule)

- 인덱스를 (A,B,C)순서로 생성했다면 Where조건에는 다음과 같이 사용되어야 한다
- (A), (A,B), (A,B,C)
- (B), (C), (B,C)와 같이 첫 번째 기준인 A가 빠진 조건으로는 인덱스를 제대로 활용할 수 없다

### 복합 인덱스 대원칙

1. 인덱스는 순서대로 사용(Index Left-Prefix Rule)
2. 등호(=) 조건은 앞으로, 범위 조건(<,>)은 뒤로
    - 범위 검색은 마지막에 한번만 사용하는 것이 가장 중요하다
3. 정렬(ORDER BY)도 인덱스 순서를 따라야 한다

### 복합 인덱스와 범위 조건

```sql
create index idx_items_category_price on items(category,price);

-- 인덱스를 타긴탔으나, filtered가 10%밖에 되지 않는다
-- 복합 인덱스에 범위 조건이 사용된다면, 이후에는 idx가 사용될 수 없다고 생각하는게 좋다
-- 패션 이후의 price는 정렬이 되어있지 않은 상태라, (인덱스 안에서) 조회해야 한다
-- 인덱스 안에서 조회하는 것은 그나마 효율적이긴 하지만, 최선의 전략은 아니다
select * from items where category >= '패션' and price = 20000;
explain select * from items where category >= '패션' and price = 20000;
```

- 복합 인덱스에서 어떤 컬럼에 범위 검색을 사용하는 순간, 그 뒤에 오는 컬럼들은 인덱스의 정렬 효과를 누릴 수 없게된다
  - 인덱스는 뒤의 자료가 정렬이 되어있지 않다고 판단해, 끝까지 검색하는 비효율적인 상황이 발생한다
  - 인덱스를 타긴 타지만, 제대로 타는 상황이 아니다
    - 범위에 따라 뒤에 있는 n개의 인덱스를 전부 검사해야 할 수 도있다
    - 문제가 터지기 좋은 상황이다
- 따라서 인덱스를 설계할 때는 = 조건으로 사용될 컬럼을 범위 조건으로 사용될 컬럼보다 앞에 배치해야하는 것이 일반적인 최적화 전략이다

#### 복합 인덱스 범위 쿼리 문제 해결방법

```sql
-- = 조건을 먼저 처리할 수 있도록 처리해야 한다
-- 장애가 날 경우, 우선 서비스가 돌아가게 해야한다(임시 방편 인덱스 생성)
create index idx_items_price_category_temp on items (price, category);
-- price 가 먼저인 인덱스를 생성해 = 조건을 먼저 판별, 이후 gt/lt 조건을 판별시킨다
```

- 인덱스를 만드는 것도 방법이지만, 가장 좋은 법은 기존에 있는 인덱스를 최대한 잘 활용하는 것이 좋다
  - IN절을 이용한 해결
    - MySQL Optimizer는 in절을 하나의 큰 범위로 취급하지 않고, 여러개의 동등 비교(=) 조건의 묶음으로 인식한다
      - category >= '패션'은 category in ('패션', '헬스/뷰티')와 논리적으로 간다
  ```sql
  explain select * from items where category >= '패션' and price = 20000;
  -- in절로 변경
  explain select * from items where category in ('패션', '헬스/뷰티') and price = 20000;
  ```
  - 핵심은 범위 검색을 동등 비교(=)의 여러 묶음으로 바꾸는 것이다
  - in query는 다음과 같이 나누어 실행된다
  ```sql
  SELECT * FROM items WHERE category = '패션' AND price = 20000;
  UNION ALL
  SELECT * FROM items WHERE category = '헬스/뷰티' AND price = 20000;
  ```
  - 즉 optimizer는 index를 이용해 ('패션', 20000), ('헬스/뷰티', 20000) 지점으로 두 번의 정확한 위치탐색(seek)을 수행한다
    - 이 과정에서 price의 조건이 반영되므로 불필요하게 데이터를 읽고 버리는 과정이 사라진다
  - 결과적으로 >, <는 '연속된 범위'로 처리되어 복합 인덱스의 추가적인 활용을 막지만, IN은 '여러 개의 개별 지점'에 대한 동등 비교(=) 묶음으로 처리된다
  - Optimizer는 in절의 각 값에 대해 인덱스를 사용한 효율적인 탐색(seek)을 여러 번 수행할 수 있으므로 복합 인덱스의 모든 컬럼을 효과적으로 사용할 수 있다

#### 실무에서는 범위가 한정적인 컬럼에 이 `IN` 트릭을 자주 사용한다.

- 예를 들어, 상품 상태를 나타내는 `status` 컬럼이 '판매중', '품절', '판매중지' 3가지 값만 가진다고 하자.
- '판매중' 또는 '품절' 상태인 상품을 찾을 때 `WHERE status >= '판매중'` 과 같이 조회하는 것보다
`WHERE status IN ('판매중', '품절')` 로 조회하는 것이 복합 인덱스를 활용하는 데 훨씬 유리할 수
있다.
- 물론, `IN` 절에 들어가는 값의 개수가 너무 많아지면 오히려 성능이 저하될 수도 있으므로, 항상 `EXPLAIN` 을 통해 실제 실행 계획을 확인하고 결정하는 것이 현명하다.

## 인덱스 설계

### 가장 중요한것: 어디에 인덱스를 만들어야하는가?

#### 카디널리티 Cardinality

- 인덱스를 어디에 걸지 판단하는 가장 중요한 기준이다
- Cardinality란 해당 컬럼에 저장된 값들의 고유성(uniqueness)정도를 나타내는 지표
  - High Cardinality: 해당 컬럼에 중복되는 값이 거의 없다
    - items의 item_id, item_name
  - Low Cardinality: 해당 컬럼의 값이 몇 종류 안되어 중복되는 값이 많다
    - items의 category, is_active
- 결론: 인덱스는 카디널리티가 높은(식별력이 좋은) 컬럼에 생성할 때 가장 효율 적이다

#### where 절에 자주 사용되는 컬럼

- 인덱스의 존재 이유 자체가 WHERE절의 검색 속도를 높이는 것이기 때문이다
- 상품을 검색할때 특정 조건으로 필터링한다면 이 컬럼들은 인덱스 생성의 우선 후보가 된다

#### JOIN의 연결고리가 되는 컬럼(외래 키에 인덱스 사용)

> FK는 성능을 위해 제거하고, 어플리케이션 레벨에서 체크하는 경우도 많다

- JOIN의 성능은 연결고리가 되는 컬럼에 인덱스가 있는지 여부에 따라 극적으로 달라진다

```sql
SELECT
  s.seller_name,
  i.item_name,
  i.price
FROM items i
JOIN sellers s ON i.seller_id = s.seller_id
WHERE s.seller_name = '행복쇼핑';
```
- 만약 위 예시에서 FK에 인덱스가 없다면 데이터베이스는 비효율적으로 동작한다
  1. sellers 테이블에서 seller_name이 '행복쇼핑' 인 판매자를 찾는다(seller_id=1)
  2. items 테이블의 모든 행을 처음부터 끝까지 스캔하면서, seller_id가 1인 상품을 하나씩 찾아낸다
- 두가지 조건의 교집합을 합치게되며, index가 없다면 join을 위해 100만번의 비교를 한다
- fk에 index가 존재한다면 다음과 같은 동작을 한다
  1. sellers 테이블에서 seller_name이 '행복쇼핑' 인 판매자를 찾는다(seller_id=1)
  2. items.seller_id 인덱스를 사용하여 seller_id가 1인 상품 데이터의 위치를 곧바로 찾아낸다. 이로 인해 풀테이블 스캔이 사라지고 몇 번의 탐색만으로 JOIN이 완료된다

- [위 쿼리의 실행 계획]

| id  | table | type  | key               | rows | Extra           |
|-----|-------|-------|-----------------|------|----------------|
| 1   | s     | const | seller_name      | 1    | Using index     |
| 1   | i     | ref   | fk_items_sellers | 5    |                 |

- 위 실행계획을 보면 seller테이블에서 인덱스를 이용해서 찾은 후 그 결과의 seller_id를 가지고 items테이블에서 fk 인덱스로 매칭한 것이다(ref)
- 논리적인 실행 계획은 FROM → JOIN → WHERE → GROUP BY … 순서이지만 이 경우 위 순서로 실행이 되지 않았다
  - Optimizer의 판단해 순서를 재배치해 더 빠른 물리적인 실행계획을 만들고 실행 한 것이다

#### Order by 절에서 자주 사용되는 컬럼

- Order by를 사용한 정렬은 데이터의 양이 많을 경우 매우 비용이 큰 작업이다
  - Database는 결과를 반환하기 전 모든 데이터를 메모리에 올리고 정렬해야 하기 때문이다
- Order by에 사용된 컬럼에 인덱스가 있다면, Database는 굳이 데이터를 따로 정렬할 필요없이, 인덱스에 있는 순서 그대로 데이터를 읽기만 하면 된다
  - 이 방식으로 비용이 큰 정렬 작업(filesort)를 완전히 건너뛸 수 있는 것이다
  - e.g. '최신 등록 상품 목록 10개'를 보여주는 `ORDER BY registered_date DESC LIMIT 10` 과 같은 쿼리는
`registered_date` 컬럼에 인덱스가 있을 때 엄청난 성능 향상을 기대할 수 있다
    - 이 쿼리는 index가 없다면 Full table scan 후 정렬해 10개를 가져온다(전부 보지 않으면 순서를 알 수 없기 때문에)

### 인덱스의 단점

1. 저장 공간
- 인덱스는 원본 테이블과는 별개로, B-Tree 구조를 가진 물리적인 파일로 디스크에 저장된다
  - 즉, 인덱스를 생성하면 그만큼의 추가 저장 공간이 필요하다
- 인덱스의 구성에 따라 다르지만 원본 테이블 크기의 약 10% 내외의 공간을 추가로 차지한다
  - 만약 100GB의 items 테이블이 있고, 여기에 5개의 인덱스를 추가 생성한다면 인덱스만으로 50GB라는 무시할 수 없는 추가 디스크 공간이 필요하게 된다
2. 쓰기 성능(INSERT, UPDATE, DELETE)
- 가장 치명적인 단점이다
- 인덱스는 SELECT의 속도를 높이는 대가로 INSERT, UPDATE, DELETE의 속도를 희생시킨다
- INSERT
  - 새로운 상품이 등록되면 테이블에 레코드가 추가된다
  - 동시에 이 테이블에 생성된 모든 인덱스의 B-Tree에도 새로운 데이터에 대한 키 값과 주소가 추가되어야 한다
    - 이 과정에서 B-Tree의 정렬 순서를 유지하고 균형을 맞추기 위한 추가적인 연산이 발생한다
  - 인덱스가 5개라면 테이블 삽입 1번에 인덱스 삽입 5번의 작업이 추가되는 셈이다
- DELETE
  - 테이블에서 레코드를 삭제하고, 모든 인덱스에서도 삭제되어야 한다
- UPDATE
  - 인덱스가 없는 컬럼의 값이 변경된다면, 인덱스는 수정할 필요가 없으므로 비교적 빠르다
  - 하지만 인덱스가 있는 컬럼의 값이 변경된다면, Database는 기존 값으로 된 인덱스 항목을 삭제하고 새로운 price값으로 인덱스 항목을 추가하는 것과 유사한 작업을 실행한다
    - 인덱스는 항상 새로운 정렬 상태를 유지해야 하기 때문이다
    - 이 작업은 insert와 delete가 동시에 발생하는 것과 같아 부하가 크다

## 결론: 균형잡힌 인덱스를 사용하는 것이 가장 중요하다

1. 워크로드 분석하기: 읽기 vs 쓰기
- 읽기 중심 서비스
  - 조회의 성능을 높이기 위해 인덱스를 비교적 자유롭게 생성해도 된다
- 쓰기 중심 서비스
  - INSERT,UPDATE가 빈번한 서비스라면 인덱스 생성에 매우 신중하고 보수적이어야 한다
  - 꼭 최소한의 인덱스만 유지해야 한다

2. 혹시나 해서 인덱스를 만들지 말아야 한다
- 사용하지 않는 인덱스는 저장 공간만 차지하고 쓰기 성능만 저하시키는 암적인 존재다
- 명확한 목적 없이 "나중에 쓸 것 같아서"라는 이유로 인덱스를 미리 만드는 것은 좋지 않다
- 반드시 느린 쿼리가 발견되었을 때, 그 쿼리를 개선하기 위한 목적으로 생성해야한다

3. 사용하지 않는 인덱스는 주기적으로 정리

- 대부분의 database에서 특정 인덱스가 얼마나 사용되었는지 모니터링하는 기능을 제공한다
- 일정 기간 아무도 사용하지 않는 인덱스가 있다면, 과감히 삭제하여 시스템 자원을 확보하고 쓰기 성능을 높여야한다
- 인덱스는 SELECT 성능을 위한 최고의 무기이지만, 저장공간과 쓰기 성능을 희생하는 양날의 검임을 확실히 인식해야한다

## 주의사항: 인덱스 컬럼은 가공하면 안된다

- WHERE절에서 인덱스가 적용된 컬럼을 함수로 감싸거나 계산을 하는 등 가공하게 되면 인덱스가 적용되지 않는다
  - e.g. where절에서 인덱스가 적용된 컬럼이 substring()같은 함수를 사용하거나 연산하면 인덱스가 작동하지 않아 테이블 전체를 스캔하게 되므로 성능이 크게 정하된다
    - `where substring(item_name, 1, 5) = '게이밍'` / `where indexed_column * 10 = 100`처럼 가공하면 데이터베이스는 정렬된 인덱스를 활용하지 못한다
  - 인덱스는 가공되지 않는 원본 값 기준으로 만들어지기 때문이다
  - 해결책: 컬럼 자체를 가공하는 대신 LIKE 연산자를 사용하여 `where item_name like '게이밍%'`와 같이 조건을 변경해야 인덱스를 효율적으로 사용할 수 있다
- SQL성능을 높이려면 인덱스 컬럼은 절대 가공하지 말고 원본 상태 그대로 사용해야 한다