# Index Advanced

## Optimizer와 인덱스 선택

- 컬럼에 인덱스를 생성하면 해당 컬럼을 조건으로 사용하는 where절의 성능이 향상될 것이라고 기대하기 쉽다
  - 하지만 항상 그렇지는 않다
  - Database의 Optimizer는 쿼리를 실행하기 전에 여러 실행 가능 방법을 평가하고 그 중 가장 비용이 적게 드는(가장 효율적인) 방법을 선택한다
  - 이 과정에서 Optimizer가 인덱스를 사용하는 것이 오히려 비효율적이라고 판단하면, 인덱스가 존재하더라도 포기하고 Full Table Scan을 선택할 수 있다
- 인덱스를 사용하면 검색 대상의 양은 줄어들지만, 테이블에 흩어진 데이터에 랜덤하게 접근해야 한다
- 풀테이블 스캔을 사용하면 items 테이블을 순서대로 쭉 읽으면 된다
- Database에서 인덱스를 통해 여러 행에 접근하는 것은 랜덤 I/O를 유발한다
- Table Full Scan의 경우 순차 I/O에 해당한다
- 조회할 데이터가 아주 많을 경우 여러 번의 랜덤 I/O를 수행하는 것보다 한 번의 순차 I/O가 더 빠를 수 있다

```sql
-- 예상 rows가 5이기에(5/25) 20%여서 인덱스를 사용한다
explain select * from items where price between 50000 and 100000;

-- 예상 rows가 25이기에(25/25) 비효율적이라고 판단해 풀 테이블 스캔을 사용한다
explain select * from items where price between 1000 and 200000;
```

- [실행 결과]
  | id | type | possible_keys | key | rows | filtered | Extra |
  |-----|-------|------------------|-----------------|------|----------|-----------------------|
  | 1 | range | idx_items_price | idx_items_price | 5 | 100.00 | Using index condition |

  | id  | type | possible_keys   | key  | rows | filtered | Extra       |
  | --- | ---- | --------------- | ---- | ---- | -------- | ----------- |
  | 1   | ALL  | idx_items_price | NULL | 25   | 76.00    | Using where |

### 인덱스 손익 분기점

- Optimizer가 인덱스 사용 여부를 결정하는 핵심기준은 바로 '손익분기점'이다
  - 인덱스를 통해 데이터를 읽는 비용이 테이블 전체를 직접 읽는 비용보다 높아지는 지점을 의미한다

```plaintext
인덱스를 사용하는 비용: 인덱스 탐색 비용+ 인덱스에서 찾은 주소로 테이블에 접근하는 비용(랜덤I/O)
풀 테이블 스캔 비용: 테이블 전체를 순차적으로 읽는 비용(순차 I/O)
```

- 일반적으로 전체 데이터의 20~25% 이상을 조회해야 하는 쿼리는 인덱스를 통해 각 행에 개별적으로 접근하는 것보다 테이블 전체를 순차 스캔하는 것이 더 효율적이다
- 즉 조회하려는 데이터의 양이 손익분기점을 넘어가면 옵티마이저는 인덱스 사용을 포기한다

#### 왜 랜덤 I/O가 더 느릴까?

- 랜덤 I/O가 순차 I/O보다 느린 이유는 데이터를 찾는 과정에서 발생하는 시간 때문이다
- 순차 I/O: 책을 1페이지부터 순서대로 읽기
  - 데이터가 저장된 위치를 한 번 찾으면, 그 이후로는 순서대로 쭉 읽기만 하면 된다
  - HDD의 경우 디스크의 헤드가 거의 움직이지 않고 연속된 데이터를 읽어오므로 작업이 매우 빠르고 효율적이다
  - SSD의 경우 "여기서부터 100개 읽어와" 라는 하나의 큰 명령으로 처리할 수 있다
- 랜덤 I/O: 책의 여러 페이지를 순서 없이 찾아 읽기
  - 5페이지를 읽은 후 200페이지를 읽고, 다시 45페이지를 읽는 방식이다
  - HDD의 경우 읽어야 할 데이터가 디스크의 여러곳에 흩어져있어, 데이터를 읽을 때마다 디스크 헤드가 물리적으로 이동해야한다
  - 이렇게 걸리는 시간(Seek time)이 추가되어 순차 I/O보다 느리다
  - SSD의 경우 100개의 작은 명령을 각각 처리해야 한다
    - 작은 명령을 여러 번 처리하는 것은 SD 컨트롤러에 더 많은 오버헤드를 준다

#### 데이터가 부족한 경우

- 데이터가 많이 없다면 옵티마이저는 풀 테이블 스캔을 선택할 가능성이 있다
- 테이블에 데이터가 몇 건 없다면 테이블 전체를 순차적으로 읽는 비용이 인덱스를 탐색하고 테이블에 접근하는 비용보다 훨씬 저렴하기 때문이다
  - 1000페이지짜리 두꺼운 책에서 index를 보고 원하는 페이지를 찾아가는 것이 빠르다
  - 하지만 3페이지짜리 얇은 소책자에서는 굳이 index를 확인할 필요 없이 1페이지부터 보는 것이 빠르다

## 커버링 인덱스

- 쿼리에 필요한 모든 컬럼을 포함하고 있는 인덱스
  - 커버링이라는 이름 그대로 인덱스 하나가 쿼리의 요구사항 전체를 '덮는다'는 의미
- 원본 테이블에 전혀 접근하지 않고 오직 인덱스만을 읽어서 쿼리를 처리한다
  - 비싼 랜덤 I/O작업을 제거하고 인덱스 순차I/O만으로 쿼리를 끝낸다

```sql
-- 새로운 인덱스를 생성해 커버링 인덱스 생성(price, item_name)
create index idx_items_price_name on items(price,item_name);
explain select item_id, price, item_name from items where price between 50000 and 100000;
```

- [실행 결과]
  | id | type | key | rows | filtered | Extra |
  |-----|-------|-----------------|------|----------|-----------------------------|
  | 1 | range | idx_items_price | 5 | 100.00 | Using where; Using index |
  - Extra: Using index
    - 쿼리에 필요한 모든 데이터를 인덱스에서만 읽어서 처리했음을 의미한다
    - 옵티마이저는 idx_items_price 인덱스만 스캔하여 price와 item_id를 모두 얻었고, 원본 items 테이블에는 전혀 접근할 필요가 없었다
  - Extra: Using where
    - 인덱스 내에서 where price between ...을 사용해 불필요한 데이터를 필터링 했음을 의미한다
    - Using index와 함께 사용되는 Using where는 테이블에 접근한 후 필터링하는 것이 아니라 인덱스 스캔 단계에서 효율적으로 필터링이 이루어졌음을 나타낸다
- 결론적으로 이 실행 계획은 커버링 인덱스를 활용해 테이블 접근을 피했고(Using index), 인덱스 내에서 where절의 조건으로 필터링(Using where)을 수행한 매우 효율적인 쿼리임을 보여준다

### 커버링 인덱스의 장단점

#### 장점

- 압도적인 SELECT성능 향상
  - 테이블 접근을 위한 랜덤 I/O를 제거하여 조회 성능을 극적으로 개선한다
- COUNT 쿼리 최적화
  - select count(\*)와 같은 쿼리에서 테이블 전체가 아닌, 크기가 훨씬 작은 인덱스만 스캔하여 결과를 빠르게 반환할 수 있다

#### 단점

- 저장 공간 증가
  - 인덱스는 원본 데이터와 별도의 저장공간을 차지한다
  - 인덱스에 포함되는 컬럼이 많아질수록 인덱스의 크기도 커진다
- 쓰기 성능 저하
  - INSERT/UPDATE/DELETE 작업 시, 테이블 데이터뿐만 아니라 인덱스도 함께 수정해야 한다
  - 인덱스가 많고 복잡할수록 쓰기 작업에 대한 부하가 커진다

### 커버링 인덱스 결론

- 커버링 인덱스는 만능 해결책이 아니며, 읽기 성능과 쓰기 성능 사이의 trade off를 고려해야 한다
  1. 조회가 매우 빈번하고, 쓰기 작업은 상대적으로 적은 테이블에 적용하는 것이 효과적이다
  2. SELECT 절에 조회하는 컬럼의 개수가 적을 때 유리하며, select \* 처럼 모든 컬럼을 조회하는 쿼리는 커버링 인덱스의 이점을 누리기 어렵다(모든 컬럼을 포함하는 인덱스를 만들 수는 있지만, 이는 사실상 테이블을 복제하는 것과 같아 매우 비효율적이다)
  3. 성능 저하가 발생하는 특정 쿼리를 튜닝하기 위한 마지막 수단인 경우가 많다

## 복합 인덱스/다중 컬럼 인덱스 Composite Index/Multi-column Index

> 실무에서 복합 인덱스를 잘못 이해해서 장애가 나는 경우가 흔하다<br>
> 이 원리를 잘 이해하고 쿼리를 작성않으면 큰 문제를 일으킬 수 있다

- 두 개 이상의 컬럼을 묶어서 하나의 인덱스로 만드는 것이다
- 컬럼의 순서가 중요하다
  - 인덱스를 어떤 컬럼 순서로 만드느냐에 따라 쿼리 성능이 하늘과 땅 차이로 달라질 수 있다

### 왜 컬럼 순서가 중요할까?

- 인덱스는 '국어 사전'과 같다
  - '첫 번째 글자'로 먼저 정렬된 후, 같은 첫 글자로 시작하는 단어들끼리 '두 번째 글자'로 다시 정렬된다
- items 테이블에 (category, price)의 복합 인덱스 생성시 내부적으로 다음과 같이 정렬 된다
  - category 기준으로 먼저 정렬한다
  - 같은 category 내에서는 price기준으로 다시 정렬한다
- [예시]
  | category | price | item_id |
  |------------|---------|---------|
  | 도서 | 18000 | 21 |
  | 도서 | 22000 | 25 |
  | 도서 | 28000 | 15 |
  | 도서 | 30000 | 4 |
  | 도서 | 35000 | 11 |
  | 생활용품 | 5000 | 16 |
  | 생활용품 | 15000 | 5 |
  | 생활용품 | 40000 | 9 |
  | 생활용품 | 60000 | 19 |
  | 전자기기 | 80000 | 3 |
  | ... | | |
- 위 테이블에서는 category로 검색이 효율적이다
- category와 price로 검색도 효율적이다
- price만으로 검색은 매우 비효율적이다
  - 이는 사전에서 앞 글자모르고 두 번째 글자로 찾는 것과 같다

### 인덱스 왼쪽 접두어 규칙(Index Left-Prefix Rule)

- 인덱스를 (A,B,C)순서로 생성했다면 Where조건에는 다음과 같이 사용되어야 한다
- (A), (A,B), (A,B,C)
- (B), (C), (B,C)와 같이 첫 번째 기준인 A가 빠진 조건으로는 인덱스를 제대로 활용할 수 없다

### 복합 인덱스 대원칙

1. 인덱스는 순서대로 사용(Index Left-Prefix Rule)
2. 등호(=) 조건은 앞으로, 범위 조건(<,>)은 뒤로
3. 정렬(ORDER BY)도 인덱스 순서를 따라야 한다