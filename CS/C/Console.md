# Console

- CLI 기반 HCL은 키보드 입력으로 구현한다
- 키보드 입력 시 그 값은 메모리(I/O Buffer)에 연속적으로 저장한다
  - 버퍼는 memory라고 생각하면 편하다
  - 즉, I/O Buffer의 경우 I/O memory라고 생각하면 편한다
  - 즉, buffer라는 것은 RAM 어딘가에 존재한다
    - RAM의 위치를 일부분 할당해, keyboard i/o, video i/o 용으로 사용한다
- I/O Buffer에서 한 글자 단위로 처리한다

## Console이 H/W와 상호작용하는 방법

- Computer에서 결국 H/W와 상호작용을 하기 위해서는 무조건 Kerner mode를 거쳐야한다
  - Console은 Kernel과 상호작용해 하드웨어를 움직이기위해 OS에서 추상화 된 인터페이스를 사용한다(File)
    - 우리가 사용하는 파일과는 조금 다르다
    - 운영체제에서 파일(File)은 단순히 디스크 위의 텍스트/이미지 같은 데이터 묶음만을 의미하지 않는다.
    - OS 입장에서는 "파일"은 추상화된 I/O 객체로, 디스크 파일(일반 파일, text, binary 등), 디렉터리, 장치(Device: 콘솔, 프린터, 키보드, 마우스 등), 소켓(Network I/O) 까지 모두 동일하게 파일 인터페이스로 접근할 수 있다
    - 즉, open(), read(), write(), close() 같은 시스템 콜을 통해 일관된 방식으로 접근할 수 있도록 OS가 추상화를 제공한다
  - Console에서 RWX(Read, Write, Execute)를 위해서는 File인터페이스를 사용해야 한다
  - CON 파일을 사용(Console, 표준 콘솔 장치, window)하여, console에 write한다

### File

- 운영체제에서 말하는 파일 인터페이스는 단순히 우리가 알고 있는 디스크에 저장된 텍스트/바이너리 파일만을 대상으로 하지 않는다.

1. 파일 인터페이스의 본질

- OS는 입출력 장치(I/O device)마다 다르게 동작하지 않도록 추상화를 제공한다.
- 그 추상화가 바로 파일 인터페이스다.
- 그래서 open(), read(), write(), close() 같은 시스템 콜은 디스크뿐만 아니라 네트워크, 콘솔, 프린터, 키보드 등 모든 I/O에 공통적으로 적용된다.

2. 디스크 파일은 우리가 흔히 접하는 예시

- 우리가 흔히 "파일"이라고 부르는 것은 디스크 위에 있는 데이터 묶음(텍스트 파일, 실행 파일, 바이너리 등)이다.
- 하지만 이것은 파일 인터페이스를 사용하는 여러 대상 중 하나일 뿐이다.

3. 다른 예시들

- 장치(Device file)
- Linux: /dev/tty, /dev/null, /dev/sda (콘솔, 버리기 장치, 디스크 장치)
- Windows: CON, PRN, NUL 같은 특수 장치 파일
- 소켓(Socket): 네트워크 통신도 결국 read()/write()로 데이터 송수신
- 파이프(Pipe, FIFO): 프로세스 간 통신(IPC)도 파일처럼 open/read/write
- 메모리 매핑 파일(Memory-mapped file): 디스크 파일 내용을 프로세스 주소 공간에 바로 매핑해서 사용

#### Fiel recap

- OS에서 "파일"은 입출력 자원을 다루는 통일된 추상화 인터페이스다
- 우리가 아는 디스크의 바이너리 파일은 그 중 가장 익숙한 예시일 뿐이다
- 실제로는 장치, 네트워크, 파이프, 심지어 가상 장치까지 다 파일 인터페이스를 통해 접근한다

#### UNIX 철학 - 모든 것은 파일이다

- 유닉스 계열 운영체제에서 파일은 단순히 디스크에 저장된 데이터가 아니라, 모든 입출력 자원(I/O resource)을 표현하는 추상화 객체다.
- 즉, 디스크 파일뿐만 아니라, 디렉터리, 장치, 네트워크 소켓, 파이프, 심지어 프로세스 정보까지도 파일 인터페이스로 다룰 수 있다는 뜻이다.
- 운영체제 설계자(특히 데니스 리치, 켄 톰슨)는 일관성을 가장 중요하게 여겼다.
  - 모든 자원을 다르게 다루면, 프로그래머는 장치마다 다른 API를 배워야 함
  - “모든 것을 파일처럼 다룬다”면, open → read/write → close라는 간단한 인터페이스만 알면 됨
  - 즉, 하나의 인터페이스로 여러 종류의 자원을 제어할 수 있는 단순함이 핵심이다.

## Computer

- Computer의 경계는 애매하지만, 일반적으로 CPU + RAM을 통해 데이터를 생성하는 것이 Computer이다
  - 이외의 것은 모두 '주변기기'이다
  - 즉, Input(keyboard)을 CPU + RAM로 처리해서 display에 결과를 output한다
    - 이 과정에서 동시성 문제가 생길 수 있다(누군가가 read중일 때 write, 혹은 write 중일때 read하는 경우)
    - OS에서는 이 과정을 해결하기 위해 Interrupt를 사용한다(전기신호를 주고받음, H/W수준에서 발생)
      - interrupt에는 번호가 존재한다
      - 키보드 입력의 인터럽트와 다른 입터럽트들은 다른 번호를 가지고있고, 이를 통해 구분한다
      - 즉, 신호를 통해 교통 정리를 하는 것이 interrupt 이다
      - OS에서 인터럽트가 몇개까지 가능한지가 중요하다(주변기기의 가능 갯수와 연관이 있다, 같은 번호를 공유해서 나눠쓰는 방법도 있어서 실제로는 더 많을 수 있다)
