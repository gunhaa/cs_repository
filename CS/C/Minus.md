# 비트 연산자와 보수를 이용한 컴퓨터의 뺄셈 구현

> 참고: https://velog.io/@c4fiber/1%EC%9D%98-%EB%B3%B4%EC%88%98%EB%B2%95-2%EC%9D%98-%EB%B3%B4%EC%88%98%EB%B2%95

## 보수/비트 연산으로 뺴기를 구현하는 이유

- 하드웨어 단순화
  - 덧셈 회로(Adder)는 이미 존재하므로, 뺄셈을 덧셈과 보수 변환으로 바꿔서 처리하면 추가 회로가 필요 없어진다
  - 즉, 뺄셈 연산을 별도로 구현할 필요 없이 덧셈기만으로 구현 가능하다
- 부호 처리 간편
  - 2의 보수를 사용하면 양수/음수 모두 같은 덧셈 회로로 처리할 수 있다
  - 음수를 나타낼 때도 2의 보수 표현을 쓰므로, 덧셈기만으로 덧셈·뺄셈이 동시에 처리된다

## 2의 보수를 사용한 뺄셈 원리

- 보수란?
  - 현재의 숫자에서 자릿수가 한 단계 올라가기 위한 수
  - r의 보수는 r-1의 보수에 +1을 해주면 된다
- 2의 보수란?
  - 어떤 수 b의 2의 보수 = 비트 반전(~b) + 1
  - 이 값을 더하면 실제로 0 - b 효과를 낼 수 있다
  - 1의 보수인 ~b를 구한후(음수화), +1을 하면 2의 보수가 된다
  - -0, +0 두개의 0이 생기는 것을 막기 위해 +1을 하는 것이다

## 예시

```plaintext

int a = 7;
int b = 5;
int result = a + (~b + 1);  // 2의 보수

a        = 00000000 00000000 00000000 00000111
b        = 00000000 00000000 00000000 00000101
~b + 1   = 11111111 11111111 11111111 11111011
a + (~b + 1) = 00000000 00000000 00000000 00000010
```

- 여기서는 carry out이 33번째 비트로 나가지만, int 범위(32비트)에서는 자동으로 무시됨
- 즉, C 표준에서 int는 overflow 비트는 버리고 하위 32비트만 결과로 남는다
