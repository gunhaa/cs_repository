# 변수와 상수 고급 이론

## 형한정어(Type qualifier)와 컴파일러 최적화

- 변수에 적용하는 문법으로 컴파일러 최적화에 깊이 관련
- const/volatile/extern/typedef

### 인터프리터와 컴파일러

- 컴파일러의 가장 큰 장점은 최적화이다
- CPU가 실행하는 것은 기계어
- C언어는 고급어로써, 기계어와 1:1로 매칭되지가 않아 최적화가 필요하다
- 이에 도움을 주는 것들이 형한정어이다

### const

- 변수를 상수화 하는 문법
- 읽기 좋은 코드를 만드는 방법 중 하나이다
- 개념상 읽기 전용으로 만들어주는 것
- 변수의 개수가 줄어들기 때문에 성능 최적화(Release mode)에 유리
  - 디버그 모드가 아닌 릴리즈 모드에서는 컴파일러가 많은 부분을 최적화 시킨다
  - const를 사용하면 릴리즈 모드에서 컴파일러가 하는 최적화에 많은 도움을 준다
- const의 사용에 따라 코드 숙련도를 알 수 있다

#### const와 포인터

- 포인터가 가리키는 대상 상수화
- 포인터 변수 자체를 상수화
- call by reference 상황에서 피호출자 함수에서 호출자가 제시한 메모리를 읽기 전용으로 차단가능
- 잘못된 행동을 하면 컴파일 타임 오류가 난다
  - 컴파일 타임 오류는 런타임 오류에 비하면 잡기가 쉬워 컴파일 오류로 내는 것이 좋다

### volatile

- const가 하는 컴파일러의 최적화를 막는 키워드
  - 컴파일 타임에 의존성이 없어 최적화가 가능하더라도 기계어로써 존재하도록 강제하는 키워드
- 임베디드 시스템에서 많이 사용한다

## 심볼릭 상수

- 프로그램 내부에서 특별한 의미를 갖는 기준 값에 대해 이름을 부여
- 읽기 좋은 코드를 만드는 방법
- 심볼릭 상수 (이름이 있는 상수) 정의에 사용(#define 전처리기로도 가능)
- 숙련된 프로그래머로 보일 수 있게한다

```C
// 심볼릭 상수
// 여러번 반복된다면 70을 하드코딩하는 것보다 유리하다

// #defint CUTOFF 70 으로도 사용 가능
const int nCUTOFF = 70;

// if(nInput >= CUTOFF)
if(nInput >= nCUTOFF)
    printf("합격");
else
    printf("불합격");
```

## 형 재선언 typedef

- 새로운 자료형을 선언하는 문법
- C언어가 제공하는 기본 형식의 이름을 바꾸는 용도로 사용
- 구조체가 공용체 선언과 조합해 편의성 확보
- 남발 시 읽기 어려운 코드가 될 우려 발생
- 꼭 필요한지 다시 한번 생각하고 사용

```C
typedef unsigned int UINT;
// long pointer
typedef const char* LPSTR;
```

## extern

- 외부 변수 선언시 사용되는 문법
- 한 프로젝트 내부에 여러 C파일이 있을 경우 다른 .c파일에 정의되어있는 전역 변수에 접근하기 위해 선언
- 같은 .c 파일에서는 내부, 다른 파일이면 외부