# 함수

- 사용자 정의 함수
- C는 함수로 시작해서 함수로 끝난다
- 함수의 모음은 Library, SDK로 불린다
- 함수는 반환 자료형 이름(매개변수 목록)형식으로 기술한다
- 호출자 함수와 피호출자 함수로 관계를 규정할 수 있다(두 함수의 Binding)
  - main()함수가 Add()함수를 호출했을 경우
  - Caller(호출자): main()
  - Callee(피호출): Add()
  - return이라는 제어문을 만나면, 제어의 흐름을 호출자 함수로 돌린다
  - Compile time Binding은 static binding
  - Runtime biding은 dynamic binding
- 호출자는 피호출자 함수의 매개변수 초기값을 기술해야 할 의무가 있다
- 피호출자 함수는 호출자 함수에게 값을 전달한다
- 기능을 만들어놓은 후, 필요할 때 호출하는 것이 함수의 목적이다(코드의 재사용)
- 함수를 식별하기 위해서 이름을 붙인다
  - 함수의 이름은 주소를 가지고 있다
  - 이 주소를 따라가면 기계어(native code)가 나온다
  - 함수는 실행코드가 저장된 메모리의 주소이다
    - Read Only
  - 함수 `nResult = Add(3,4)`에서 함수 호출시 사용되는 괄호( (,) ) 는 함수 호출 연산자이다
- 함수의 시그니처부터 잘 정하고 시작해야한다(이름, 파라미터, 반환형)

## 두 가지 함수 설계 원칙

- UI와 기능은 반드시 분리
  - 안한다면 반드시 후회할 일이 생긴다
  - 웹 개발에서는 특히 잘 분리되어있다(fe- UI, be-비즈니스 로직)
- 재사용 가능한 단위 코드는 함수로 구현(DRY 원칙, Do not Repeat yourself)
  - 유지 보수성을 위해서

## (사용자 입력) 이벤트 루프

- main()함수에서 사용자 인터페이스 출력 및 사용자 입력을 반복하는 구조
- 보통 메뉴출력과 사용자 선택을 확인
- 메뉴 선택에 따라 기능 수행
- 일반적인 응용 프로그램 유저 인터페이스의 대부분이 채택하는 구조
- 윈도우의 '응답없음'은 윈도우 이벤트루프에서 입력을 받고 처리를 하는 과정이 오래걸리게되어 멈춘 상태이다(Suspended)

## 함수 원형(시그니처) 선언

> `int main(void);` 로 선언한다

- 함수의 선언과 정의를 분리
- 컴파일러에게 함수의 존재를 알리기 위해 분리한 선언을 코드 상단에 기술
  - 함수 원형 선언의 핵심 이유이다
  - 컴파일 중 함수의 존재를 모르면 오류가 나게되어 필요한 선언이다
    - 컴파일은 위에서 아래로 이루어지기에 생기는 일이다
- 함수 바디 없이 원형만 기술할 경우 함수 시그니처라고 부르기도 함
- 함수 원형 선언에서는 매개변수 이름은 생략가능
- C는 헤더 파일에 시그니처들을 모아둔다

```C
#include <stdio.h>
#include "func.h"

// 원형 시그니처(선언)
int Add(int, int);

int main(void)
{
  printf("%d\n", Add(3,4));
  return 0;
}

// 함수의 정의
// 선언만 있고 정의가 없다면 링크 오류가 발생한다
int Add(int x, int y)
{
  return x + y;
}

```

## 분할 컴파일

- 한 프로젝트에 여러 소스코드 파일(.c)을 운영하는 경우 각각을 개별 컴파일
- 개별 소스코드에 대한 목적 파일 생성
- 변수나 함수 선언과 정의가 다른 파일로 분리 될 수 있음
- 링크 오류에 주의

## 전역변수와 식별자 검색 순서

- 햇갈릴일이 많아 조심히 써야한다
- 전역변수는 함수 바디 밖에 선언(=/ 지역 변수, 자동, 스택 메모리 사용)
  - 전역 변수는 정적 영역을 사용한다
  - 할수만 있다면 정적 영역을 사용하지 않는 것이 가장 좋다(C#, Java는 전역 변수가 존재하지 않는다)
- 식별자 검색 순서
  1. 지역 스코프
  2. 최대 함수 바디
  3. 최대 로컬 파일
  4. 외부 파일까지 확장