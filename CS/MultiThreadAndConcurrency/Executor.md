# 스레드 풀과 Executor 프레임워크

- 실무에서 스레드를 생성하는 일은 드물다
- 대신에 Executor 프레임워크를 주로 사용한다

## 스레드를 직접 사용할 떄의 문제점

1. 스레드 생성 시간으로 인한 성능 문제

- 각 스레드는 자신만의 호출 스택을 가지고 있어야하기에, 호출스택을 위한 메모리를 할당해야 한다
- 스레드 생성하는 작업은 운영체제 커널 수준에서 이루어지며, 시스템 콜을 통해 처리된다. 이는 CPU와 메모리 리소스를 소모하는 작업이다
- 새로운 스레드가 생성되면 운영체제 스케줄러는 이 스레드를 관리하고 실행 순서를 조정해야하며, 운영체제 스케줄링 알고리즘에 따라 추가적인 오버헤드가 발생할 수 있다
- 스레드를 생성하는 작업은 상대적으로 무거우며, 자바 객체 하나 생성과는 비교 불가능한 큰 작업이다
  - 하나의 스레드는 1mb 이상의 메모리를 사용한다
- 작업을 수행할때마다 스레드를 생성하고 실행한다면, 생성 비용 때문에 많은 시간이 소모되며 작업의 실행시간보다 스레드의 생성시간이 더 오래 걸릴 수 있다
  - 스레드를 재사용하면 처음 생성할 떄를 제외하고는 생성을 위한 시간이 들지 않아, 빠르게 작업을 수행할 수 있다

2. 스레드 관리 문제

- 서버의 CPU, 메모리 자원은 한정되어 있어 스레드는 무한하게 만들 수 없다
  - 스레드를 만들어서 처리하는 요청의 경우, 갑자기 트래픽이 몰려 스레드가 많이 만들어지면 CPU, 메모리 자원이 버티지 못한다
  - 이런 문제를 해결하기 위해서는 최대 스레드 수 까지만 스레드를 생성할 수 있게 관리해야 한다

3. Runnable 인터페이스의 불편함

- 반환 값이 없다
- 예외 처리: 체크 예외를 던질 수 없다, 메서드 내부에서 반드시 처리해야 한다

### 해결 방법

- 스레드 풀 생성
  - 생산자, 소비자 문제가 발생한다
- 자바가 제공하는 Executor 프레임워크를 통해 해결할 수 있다

## Executor 프레임워크

- java의 executor 프레임워크는 멀티스레딩 및 병렬 처리를 쉽게 사용할 수 있도록 돕는 기능의 모음이다. 
  - 작업 실행의 관리 및 스레드 풀 관리를 효율적으로 처리해서 개발자가 직접 스레드를 생성하고 관리하는 복잡함을 줄여준다
- ExecutorService 인터페이스를 주로 사용하며, Future Callable에 대한 이해가 필요하다
  - Callable은 Runnable과 비슷하지만 반환값이 있다