# JAVA의 배열에는 왜 toString()을 오버라이딩 시키지 않았나?

> 자바에서 배열의 toString() 메서드가 오버라이딩되지 않은 이유는 설계 철학과 배열의 특수성에 기인한다. 배열은 자바에서 특별히 다뤄지는 데이터 구조로, 객체와 비슷하지만 일반적인 클래스와는 다른 방식으로 작동한다.

## 1. 배열의 설계 철학

배열은 자바에서 가장 기본적인 데이터 구조이며, 다른 객체들과 다르게 특수한 형태의 객체로 취급된다. 자바는 배열을 효율적으로 설계하기 위해 배열에 대한 기능을 **별도의 유틸리티 클래스(java.util.Arrays)** 에 집중시켰다. 배열 객체에 자체적으로 많은 메서드를 추가하면 배열의 경량성을 해칠 수 있기 때문에 배열 객체 자체에는 최소한의 기능만 제공된다.

배열은 객체이긴 하지만, 메서드가 많아지면 오히려 메모리 사용량과 성능에 부정적인 영향을 미칠 수 있다. 따라서 복잡한 작업은 Arrays와 같은 유틸리티 클래스로 분리되었다.

## 2. Object 클래스의 설계와 배열
자바에서 모든 클래스는 Object 클래스를 상속받으며, 배열 역시 예외는 아니다. 기본적으로 Object 클래스의 toString() 메서드는 클래스 이름 + @ + 해시코드를 반환한다.

배열은 이러한 기본 구현을 따르고 있으며, 배열만을 위해 toString()을 별도로 오버라이딩하지 않았다. 이는 배열의 특별한 특성 때문이다.

- 배열은 고정된 구조로 사용되며, 객체처럼 동작하지 않습니다.
- 배열은 일반적인 객체보다 효율성과 단순함이 중요합니다.

## 3. toString() 오버라이딩의 필요성

배열의 내용을 출력하려는 경우는 일반적으로 디버깅이나 로깅 상황에 국한된다. 자바는 이런 작업을 위해 Arrays.toString() 및 Arrays.deepToString() 메서드를 제공한다. 배열이 특별한 데이터 구조인 만큼, 자바 개발자들은 이런 작업을 별도의 유틸리티 클래스에서 처리하는 것이 적합하다고 판단했다.

## 4. 유틸리티 클래스와의 역할 분리

자바는 **SRP(Single Responsibility Principle, 단일 책임 원칙)** 에 따라 배열 객체와 배열 처리 로직을 분리했습니다. 배열 자체는 데이터를 저장하는 역할만 담당하고, 데이터 표현과 같은 부가적인 작업은 Arrays 유틸리티 클래스가 담당한다.

- Arrays.toString(): 1차원 배열의 요소를 문자열로 변환한다.
- Arrays.deepToString(): 다차원 배열을 포함한 배열의 모든 내용을 문자열로 변환한다.
```java
int[] arr = {1, 2, 3};
System.out.println(Arrays.toString(arr));  // [1, 2, 3]
```