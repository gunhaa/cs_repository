# COMMIT의 실제 동작 원리

> COMMIT은 단순히 트랜잭션을 종료하는 명령이 아니라, 사용자가 변경한 데이터가 영구적으로 저장되었음을 보장하는 약속이다.
> 이 과정은 메모리(버퍼)와 디스크(파일), 그리고 여러 백그라운드 프로세스 간의 유기적인 상호작용을 통해 이루어진다.

## 용어

- 버퍼 캐시 (Buffer Cache): 데이터 파일에서 읽어온 데이터 블록의 복사본을 저장하는 메모리 영역이다. 모든 데이터 변경 작업은 디스크가 아닌 이 버퍼 캐시에서 먼저 일어난다.
- 리두 로그 버퍼 (Redo Log Buffer): 데이터에 발생한 모든 변경사항(redo entries)을 순차적으로 기록하는 메모리 영역이다. 데이터 복구에 사용되는 핵심 정보다.
- 데이터 파일 (Data File): 실제 데이터가 저장되는 디스크 상의 물리적인 파일이다.
- 리두 로그 파일 (Redo Log File): 리두 로그 버퍼의 내용이 영구적으로 기록되는 디스크 상의 물리적인 파일이다. 시스템 장애 발생 시 복구의 기준점이 된다.
- LGWR (Log Writer): 리두 로그 버퍼의 내용을 리두 로그 파일에 기록하는 백그라운드 프로세스다. 매우 빠르고 중요도가 높다.
- DBWR (Database Writer): 버퍼 캐시에서 변경된 블록(Dirty Buffer)들을 데이터 파일에 기록하는 백그라운드 프로세스다.
- SCN (System Change Number): 데이터베이스 전체에서 트랜잭션의 순서를 식별하기 위해 사용하는, 계속해서 증가하는 고유한 번호다. COMMIT 시점에 할당되어 트랜잭션의 완결을 보증한다.

## COMMIT 동작 순서

1. DML 실행 및 변경 정보 생성

   - 사용자가 INSERT, UPDATE, DELETE 같은 DML 구문을 실행한다.
   - 서버 프로세스는 이 변경사항을 되돌리기 위한 정보(Undo)와 다시 실행하기 위한 정보(Redo)를 생성한다.
   - 생성된 Redo 정보는 즉시 리두 로그 버퍼에 기록된다.

2. 버퍼 캐시의 데이터 블록 변경

   - 데이터 파일이 아닌 메모리의 버퍼 캐시에 있는 데이터 블록을 찾아 내용을 변경한다.
   - 만약 버퍼 캐시에 해당 블록이 없다면, 먼저 데이터 파일에서 블록을 읽어와 버퍼 캐시에 적재한 후 변경 작업을 수행한다.
   - 이렇게 변경된 버퍼 블록을 '더티 버퍼(Dirty Buffer)'라고 부른다.

3. COMMIT 명령어 실행

   - 사용자가 COMMIT 명령을 내린다.
   - 트랜잭션에 고유한 SCN이 할당되고, 이 SCN 정보가 리두 로그 버퍼에 함께 기록된다.
   - 사용자 세션은 LGWR의 작업이 완료될 때까지 `동기적인` 대기 상태에 들어간다.

4. LGWR, 리두 로그 파일에 기록 (COMMIT의 실체)

   - COMMIT이 발생하면 LGWR 프로세스가 즉시 동작한다.
   - 리두 로그 버퍼에 기록된 트랜잭션의 변경 이력(Redo 정보와 SCN)을 디스크의 리두 로그 파일에 물리적으로 기록(I/O)한다.
   - 이 작업이 성공적으로 완료되는 순간, 트랜잭션은 영구적으로 보존된 것으로 간주하며 COMMIT이 완료된다.
   - LGWR의 작업이 완료되면, 대기하던 사용자 세션에 COMMIT 성공이 통보된다.

5. DBWR, 데이터 파일에 기록 (지연된 쓰기)

   - DBWR은 COMMIT과는 `비동기적`으로, 주기적으로 활동한다.
   - 버퍼 캐시에 쌓여있는 더티 버퍼들을 모아서 데이터 파일에 기록한다.
   - 이 작업은 I/O 효율을 위해 여러 변경사항을 한 번에 처리하며, COMMIT 시점에 즉시 발생하지 않는다. 이를 '지연된 쓰기(Deferred Write)'라고 한다.

## 의문점과 답

1. 리두 로그는 일종의 안전장치인가?
- 리두 로그는 데이터베이스의 가장 중요한 안전장치
- COMMIT된 데이터가 절대 유실되지 않는다는 영속성을 보장하는 핵심적인 역할을 한다

2. Redo로그는 성능을 희생시킬 만큼 가치가 있어서 두번 I/O를 발생시키는가? 왜 비효율적인 I/O 작업을 두번이나 하는가?

- I/O 작업의 비용(cost)은 전혀 같지 않다
- 리두 로그 파일에 쓰는 I/O (by LGWR)는 순차 쓰기(Sequential Write) 방식이다
  - 기존 파일의 맨 끝에 내용을 계속 이어서 붙여나가는 방식이라 디스크 헤드가 거의 움직이지 않는다.
  - 따라서 매우 빠르고 비용이 저렴하다
  - 디스크의 읽기/쓰기 헤드가 다음 기록 위치로 바로 이동할 수 있기 때문에 탐색 시간이 거의 걸리지 않는다
  - 파일의 끝을 찾는 것은 매우 빠른 작업이라 O(1)에 가까운 비용이 든다
    - 운영체제의 파일 시스템이 파일의 끝(End-Of-File) 위치를 이미 알고 있기 때문에 디스크 헤드는 다른 곳을 탐색할 필요 없이 바로 그 위치로 이동해서 순차적으로 데이터를 기록한다
    - 그에 비해 데이터파일에 쓰는 것은 디스크가 작업에 필요한 위치를 여러번 찾으며 디스크가 움직이는 동작이 누적되기 떄문에 매우 느리다
- 데이터 파일에 쓰는 I/O (by DBWR): 이것은 랜덤 쓰기(Random Write) 방식이다
  - 변경된 데이터 블록들이 디스크의 여러 위치에 흩어져 있기 때문에, 디스크 헤드가 이리저리 바쁘게 움직여야 한다 
  - 그래서 매우 느리고 비용이 비싸다
- 데이터베이스는 바로 이 비용 차이를 이용한다
- COMMIT 시점에는 비용이 싼(빠른) 리두 로그 파일 쓰기만 완료되면 즉시 사용자에게 성공을 알린다 
- 그리고 비용이 비싼(느린) 데이터 파일 쓰기는 DBWR이 나중에 한가할 때 모아서 처리하는 것이다


## Recap

- COMMIT의 본질은 '변경된 데이터 블록(더티 버퍼)이 데이터 파일에 쓰이는 것'이 아니라, '변경 이력(리두 로그)이 리두 로그 파일에 안전하게 기록되는 것'이다
  - COMMIT이 완료되었더라도, 실제 데이터는 아직 메모리(버퍼 캐시)에만 존재하고 데이터 파일에는 반영되지 않았을 수 있다
  - 즉, COMMIT후 리두 로그 버퍼가 I/O가 일어나기 전에 오류가 발생한 경우는 COMMIT이 실패한 판정이다  
- 하지만 리두 로그 파일에 변경 이력이 기록되었기 때문에, 만약 데이터 파일에 쓰이기 전에 시스템이 비정상 종료되더라도 데이터베이스 재시작 시 리두 로그를 통해 모든 COMMIT된 변경사항을 완벽하게 복구할 수 있다
- 이러한 'Fast Commit' 메커니즘 덕분에 데이터의 영속성을 보장하면서도 I/O 병목 현상을 최소화하여 높은 성능을 유지할 수 있다