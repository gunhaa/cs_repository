# UPDATE와 DELETE

```sql
UPDATE member SET name = '루피' WHERE age > 20;
```

- 위 SQL문이 실행될 때 InnoDB 스토리지 엔진에서 일어나는 실제 동작은 다음과 같다.

1. 수정 대상 레코드 검색

- UPDATE문은 일반 SELECT문처럼 특정 시점의 **_스냅샷(ReadView)을 생성하지 않는다_**.
  - InnoDB의 Repeatable Read 격리 수준에서 사용되는 특유의 Snapshot(ReadView)은 사용되지 않는다
  - 대신 Undo로그를 기록한 후 진행한다
- 대신, 수정할 최신 버전의 데이터를 찾기 위해 Locking Read(데이터를 읽으면서 해당 레코드에 Lock을 거는 읽기 방식)를 수행한다.
- WHERE절의 조건(age > 20)을 만족하는 레코드를 찾기 위해 인덱스를 사용하거나, 적절한 인덱스가 없다면 테이블 전체를 스캔한다.
  - 스캔 과정에서 다른 트랜잭션이 Lock을 선점하고 있는 레코드를 발견하면, Lock을 획득할 때까지 Blocking한다.

2. 레코드 단위 잠금 및 수정 작업 (반복)

- 검색된 각 레코드에 대해 다음 작업을 순차적으로 수행한다.
  - X Lock (배타적 잠금) 획득: 다른 트랜잭션이 동시에 수정하는 것을 막기 위해 해당 레코드에 X Lock을 설정한다.
    - 만약 다른 트랜잭션이 이미 해당 레코드에 락을 걸고 있다면, 락을 획득할 때까지 대기하며, 이 과정에서 Lock Wait Timeout 또는 Deadlock이 발생할 수 있다.
    - 이 X Lock은 트랜잭션이 종료(COMMIT 또는 ROLLBACK)될 때까지 절대 해제되지 않는다.
  - Undo Log 생성: 데이터 변경 전의 원본 값을 Undo Log에 기록한다. 이는 트랜잭션 롤백이나 다른 트랜잭션의 일관된 읽기(MVCC)를 위해 사용된다.
  - 실제 데이터 변경: 메모리(버퍼 풀)에 있는 레코드의 name 컬럼을 '루피'로 수정한다.
  - Redo Log 기록: 데이터 변경 사항을 Redo Log에 기록한다. 이는 시스템 장애 발생 시 데이터 복구를 보장하는 역할을 한다.

3. 트랜잭션 종료

- UPDATE문이 모든 대상 레코드의 수정을 완료하고 COMMIT이 실행되면, 트랜잭션이 영구적으로 반영된다.
- COMMIT 또는 ROLLBACK 시점에 트랜잭션 동안 획득했던 모든 X Lock이 비로소 해제된다.

## Undo 로그와 스냅샷(ReadView)은 어떻게 다른가?

> Undo 로그는 데이터의 여러 버전을 저장하는 역할
> 스냅샷(ReadView)은 어떤 버전을 읽어야 할지 결정하는 ‘필터’ 역할

- Undo 로그
  - 변경된 데이터의 이전 버전을 저장하는 로그
  - MVCC가 여러 버전을 관리할 수 있게 하는 핵심 자료구조
  - 모든 변경 트랜잭션에 대해 유지됨 (롤백 및 일관성 유지를 위해 필요)
- 스냅샷(ReadView)
  - 특정 시점에서 어떤 트랜잭션이 커밋됐는지 판단하기 위해 생성된 트랜잭션 ID 상태 정보 모음
  - 쿼리가 시작된 시점의 트랜잭션 상태를 고정해서, 읽기 일관성을 제공

## RECAP

- 읽기만 필요한 경우: 스냅샷 기반 SELECT로 성능과 동시성 확보
- 변경이 수반되는 경우: UPDATE, DELETE 등은 X Lock을 통해 정확성과 일관성 확보
  - UPDATE, DELETE의 진행 로직에 SELECT가 포함되지만, 변경하려는 대상이 실제 존재하고, 다른 트랜잭션과 충돌이 없는지를 정확히 확인해야 하므로 X Lock을 걸고, 그 잠금이 확보된 이후에 변경 작업을 수행해야 함