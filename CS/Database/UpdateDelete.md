# UPDATE와 DELETE

```sql
UPDATE member SET name = '루피' WHERE age > 20;
```

- 위 SQL문이 실행될 때 InnoDB 스토리지 엔진에서 일어나는 실제 동작은 다음과 같다.

1. 수정 대상 레코드 검색
- UPDATE문은 일반 SELECT문처럼 특정 시점의 ***스냅샷(ReadView)을 생성하지 않는다***. 
  - 즉, InnoDB의 Repeatable Read 격리 수준에서 사용되는 특유의 Snapshot(ReadView)은 사용되지 않는다.
- 대신, 수정할 최신 버전의 데이터를 찾기 위해 Locking Read(데이터를 읽으면서 해당 레코드에 Lock을 거는 읽기 방식)를 수행한다. 
- WHERE절의 조건(age > 20)을 만족하는 레코드를 찾기 위해 인덱스를 사용하거나, 적절한 인덱스가 없다면 테이블 전체를 스캔한다.
  - 스캔 과정에서 다른 트랜잭션이 Lock을 선점하고 있는 레코드를 발견하면, Lock을 획득할 때까지 Blocking한다.
1. 레코드 단위 잠금 및 수정 작업 (반복)
- 검색된 각 레코드에 대해 다음 작업을 순차적으로 수행한다.
  - X Lock (배타적 잠금) 획득: 다른 트랜잭션이 동시에 수정하는 것을 막기 위해 해당 레코드에 X Lock을 설정한다.
    - 만약 다른 트랜잭션이 이미 해당 레코드에 락을 걸고 있다면, 락을 획득할 때까지 대기하며, 이 과정에서 Lock Wait Timeout 또는 Deadlock이 발생할 수 있다.
    - 이 X Lock은 트랜잭션이 종료(COMMIT 또는 ROLLBACK)될 때까지 절대 해제되지 않는다.
  - Undo Log 생성: 데이터 변경 전의 원본 값을 Undo Log에 기록한다. 이는 트랜잭션 롤백이나 다른 트랜잭션의 일관된 읽기(MVCC)를 위해 사용된다.
  - 실제 데이터 변경: 메모리(버퍼 풀)에 있는 레코드의 name 컬럼을 '루피'로 수정한다.
  - Redo Log 기록: 데이터 변경 사항을 Redo Log에 기록한다. 이는 시스템 장애 발생 시 데이터 복구를 보장하는 역할을 한다.
1. 트랜잭션 종료
- UPDATE문이 모든 대상 레코드의 수정을 완료하고 COMMIT이 실행되면, 트랜잭션이 영구적으로 반영된다.
- COMMIT 또는 ROLLBACK 시점에 트랜잭션 동안 획득했던 모든 X Lock이 비로소 해제된다.