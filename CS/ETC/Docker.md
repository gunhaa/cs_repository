# Docker

- 도커는 컨테이너 기술이다.
    - 컨테이너를 생성하고 관리하기 위한 도구
    - 소프트웨어 개발에서의 컨테이너란?
        - 표준화된 소프트웨어 유닛
        - A package of code and dependencies to run that code
        - e.g. nodejs code + the nodejs runtime
        - ** 여기서의 runtime : 프로그램이 실행될 수 있는 환경을 제공하는 것

## 도커는 왜 필요한가?
- 소프트웨어 개발에서 독립적인 표준화된 어플리케이션 패키지를 원하는 이유는?
    - 언제나 같은 실행을 보장하기 위해서
    - 개발 환경과 프로덕션 환경의 동일성을 보장하기 위해서
    - 팀이나 회사에서 프로젝트의 크기가 커졌을때 프로그램의 버전을 서로 맞추기 어려우며, 같은 코드 기반에서 작업을 하기위해 많은 소모값이 있다.
        - 특히나 종속성이 많은 라이브러리들에서 문제가 생길 확률이 높다.
    - 혼자 작업할때도 유용하다. 작업하는 프로젝트가 여러 개인 경우 충돌하는 버전이 있을 수도 있기 때문이다.
        - python2 와 최신 버전이 충돌하는 경우가 있을 수 있다.
        - 작업을 전환할때마다 버전을 삭제하고, 설치하기는 너무 번거롭다.

```javascript

// 예시코드
import express from 'express';

import connectToDatabase from './helpers.mjs'

const app = express();

app.get('/', (req, res) => {
    res.send('<h2>Hi there!</h2>');
})

// node 14버전 이상부터 await을 사용 가능하다.
// 배포 환경이 12, 8 같은 버전의 node라면 해당 코드는 에러를 일으킨다
// 이 문제를 찾는데 시간이 많이 걸릴 수 있다.
// 개발 환경과 실제 프로덕션 환경이 다를 가능성이 존재하고, 
// 이를 해결하기 위해 Container를 이용해 정확한 버전을 실행시킬 수 있다.
await connectToDatabase();

app.listen(3000);
```
## 도커를 공부하기 위해 알아야 할 개념
 1. 프로세스 관리 (Process Management)
    - 도커의 기본적인 개념은 컨테이너라는 독립적인 실행 환경을 만들어 여러 프로세스를 격리시키는 것이다. 따라서, 프로세스가 어떻게 실행되고 관리되는지 이해하는 것이 중요하다
 2. 네임스페이스 (Namespaces)
    - 도커는 리눅스 네임스페이스를 사용하여 프로세스, 네트워크, 파일 시스템 등 다양한 리소스를 격리한다. 각 컨테이너는 다른 컨테이너와 독립적으로 실행되며, 이를 가능하게 하는 핵심 기술이 네임스페이스이다.
 3. 컨트롤 그룹 (Control Groups, cgroups)
    - cgroups는 리눅스 커널 기능으로, 프로세스에 대한 리소스 할당을 관리합니다. 도커는 이 기능을 사용하여 각 컨테이너에 할당된 CPU, 메모리, I/O와 같은 리소스를 제한하고 관리한다.
    - cgroups를 통해 도커는 각 컨테이너가 사용할 수 있는 자원의 양을 조절하며, 과도한 리소스 사용을 방지하고 성능을 최적화합니다.
리소스 제한, 우선순위 설정 등을 공부하는 것이 좋습니다.
 4. 파일 시스템과 가상화
    - 도커는 파일 시스템 격리를 위해 Union File System(예: AUFS, OverlayFS 등)을 사용하여, 여러 이미지와 컨테이너가 공유하는 파일 시스템 구조를 효율적으로 관리합니다.
    - 각 컨테이너는 읽기 전용 이미지와 읽기/쓰기 레이어로 구성된 파일 시스템을 사용하여 독립적인 환경을 구성합니다.
    - 파일 시스템과 가상화 기술에 대한 이해는 도커가 어떻게 여러 컨테이너를 효율적으로 실행하는지 이해하는 데 도움이 됩니다.
 5. 네트워크 (Networking)
    - 도커는 여러 가지 네트워크 드라이버를 제공하여, 각 컨테이너 간의 통신을 관리합니다. 네트워크의 격리, 포트 매핑, DNS 설정 등 다양한 기능을 제공합니다.
    - 컨테이너는 독립적인 네트워크 네임스페이스를 가지며, 서로 다른 네트워크에 속한 컨테이너들 간에는 기본적으로 통신할 수 없습니다.
    - Docker Network (bridge, host, overlay 네트워크 등)와 관련된 개념을 이해하면 도커의 네트워크 구성 방식에 대해 더 잘 알 수 있습니다.
 6. 운영 체제의 커널 (Kernel)
    - 도커는 커널 기반의 가상화 기술을 사용합니다. 즉, 하드웨어 가상화와 달리, 도커는 호스트 운영 체제의 커널을 공유하면서 - 프로세스 격리 및 리소스 할당을 처리합니다.
    - 커널이 어떻게 컨테이너화된 환경에서 다양한 기능을 처리하는지 이해하는 것이 중요합니다.
    - 커널 모듈, 시스템 콜, 컨텍스트 스위칭 등을 이해하는 것이 유용할 수 있습니다.
 7. 시스템 호출 (System Calls)
    - 도커는 컨테이너화된 환경에서 여러 시스템 리소스를 시스템 호출을 통해 관리합니다. 시스템 호출은 운영 체제가 제공하는 서비스와 상호작용하는 주요 방법입니다.
    - 예를 들어, 도커는 컨테이너 내에서 파일 시스템 조작, 프로세스 관리, 네트워크 구성 등의 작업을 수행하기 위해 시스템 호출을 사용합니다.
    - 시스템 콜 인터페이스에 대해 공부하면 도커가 어떻게 리눅스 커널과 상호작용하는지 이해하는 데 도움이 됩니다.

- 즉, 도커는 프로세스를 격리하고, 프로세스에 필요한 컴퓨팅 자원을 독립적으로 할당/격리하여 완벽히 격리된 가상 환경을 구축하게 해준다. 

## 도커 컨테이너의 작동 원리

> https://anweh.tistory.com/67

## VM과 Container

![docker1](images/docker1.png)

- VM은 각 머신마다 OS를 설치해야하기 때문에 낭비가 심하다.
- 하이퍼바이저는 물리적 서버의 리소스(CPU, 메모리, 디스크 등)를 가상 머신에게 할당하고, 각 가상 머신이 실제 하드웨어처럼 동작하도록 관리한다. 이를 통해 여러 운영 체제(OS)가 하나의 물리적인 서버에서 독립적으로 실행될 수 있다.
- 운영체제가 도커를 지원한다면 가상머신이 필요 없을 것이다.
- 가상머신을 사용하지 않는 것이 이상적이다.

### Docker Containers
- Low impact on OS, very fast, minimal disk space usage
- Sharing, re-building and distribution is easy
- Encapsulate apps/ environments instead of "whole machines"

### Virtual machines
- Bigger impact on OS, slower, higher disk space usage
- Sharing, re-building and distribution can be challenging
- Encapsulate "whole machines" instead of just apps/ environments

| 항목                        | **도커 컨테이너**                                    | **가상 머신**                                    |
|-----------------------------|---------------------------------------------------|-------------------------------------------------|
| **운영 체제에 미치는 영향**     | OS에 미치는 영향이 적고, 빠르게 실행됨.               | OS에 더 큰 영향을 미치며, 더 많은 리소스를 소모함. |
| **속도**                     | 매우 빠르며, 실행 속도가 빠름.                        | 상대적으로 느림. 가상화된 전체 시스템을 실행하므로 속도가 떨어짐. |
| **디스크 공간 사용**           | 디스크 공간을 적게 사용, 작은 크기의 이미지를 생성.   | 디스크 공간을 많이 사용, 전체 운영 체제를 포함하는 이미지를 생성. |
| **재구성 및 배포**              | 앱 및 환경을 캡슐화하여 쉽게 공유, 재구성 및 배포가 용이. | 전체 머신을 캡슐화하므로 공유 및 배포가 복잡하고 시간이 걸림. |
| **캡슐화 대상**                | 애플리케이션 및 해당 환경만 캡슐화.                    | 전체 머신을 캡슐화 (운영 체제 포함).               |
| **자원 격리**                  | 커널을 공유하지만, 각 컨테이너는 격리된 환경에서 실행.   | 하이퍼바이저가 각각의 가상 머신을 완전히 격리된 독립적인 환경으로 실행. |
| **시작 시간**                  | 매우 빠르게 시작됨.                                   | 시작하는 데 시간이 오래 걸림.                    |
| **OS 커널 공유**               | 호스트 OS의 커널을 공유.                             | 각 가상 머신은 자체 커널을 가짐.                  |
| **보안**                      | 보안 격리가 상대적으로 약할 수 있음.                   | 보안이 더 강력함. 각 가상 머신은 독립적인 운영 체제를 가짐. |
| **애플리케이션 격리**           | 애플리케이션의 격리가 필요하지만, 보통은 공유된 커널을 사용. | 각 가상 머신이 완전히 독립된 환경을 제공하므로 애플리케이션 격리가 강력함. |
| **호스트 시스템 의존성**       | 호스트 OS와 더 밀접하게 연관되어 있으므로, 호스트 OS에 따라 다를 수 있음. | 호스트 시스템과 독립적인 환경에서 실행되므로 호스트 OS와 관계가 적음. |
| **리소스 효율성**               | 리소스를 효율적으로 사용함 (CPU, 메모리, 디스크 등).    | 리소스 소모가 많음 (각 가상 머신에 별도의 운영 체제와 자원이 필요). |
| **사용 사례**                  | 빠른 개발, CI/CD, 마이크로서비스, 애플리케이션 격리 등. | 전체 운영 체제를 필요로 하는 애플리케이션, 레거시 시스템, 높은 보안 요구사항 등이 있는 경우. |
