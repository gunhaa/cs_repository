# 좋은 코드를 짜기 위한 원칙

## 1. 간결한 코드를 작성하기

- 첫 번째 원칙은 가장 간결한 코드를 작성하는 것이다
  - 코드가 짧으면 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워지기 때문이다
  - 같은 일을 하는 100줄짜리 코드 대신 1000줄짜리 코드를 보고 싶어하는 사람은 아무도 없듯이, 이 원칙은 어느 프로그램에나 적용되는 것이다
- 하지만 프로그래밍 대회에서는 경우에 따라 일반적이지 않은 방법을 사용할 수 있다
  - 전역 변수의 광범위한 사용이 그러하다
  - 일반적으로는 프로그램의 흐름을 파악하기 어려워져 대개 사용하지 않는 것이 좋다
  - 하지만 프로그래밍 대회에서 작성하는 코드는 구조가 매우 단순하고, 각 변수를 읽고 쓰는 부분이 명확하기 때문에 전역변수를 쓰더라도 잃는 것이 그렇게 많지 않다
  - 프로그래밍 대회에서는 일반적인 코딩과 다르게 사용하는 언어의 특수한 기능을 사용한 특수한 테크닉도 많이 사용한다(cpp의 매크로를 이용한 간결함 유지 등)

## 2. 적극적으로 코드를 재사용하기

- 간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드를 모듈화하는 것이다
  - 같은 코드가 세 번이상 등장한다면 항상 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만들면 좋다
- 시간이 없다고해서 코드를 더 알기 쉽게 고치는 데 주저해서는 안된다
- 당장은 차이점이 없더라도 항상 코드를 깔금하게 작성하고 유지하는 데 신경을 쓰다 보면 사람은 스스로 그와 같은 코드에 익숙해지기 때문이다
  - 간결한 코드에 익숙해진 사람은 다음 번에 비슷한 코드를 짤 때 처음부터 좀 더 간결하게 코딩할 수 있게 된다
- 가장 이상적인 실무의 코드는 한 함수가 두 가지 이상의 일을 하지 않는 것이다
  - 프로그래밍 대회에서는 이 정도로 원칙을 따르지는 못한다

## 3. 표준 라이브러리 공부하기

- 간결한 코드를 작성하기 위한 또 다른 중요한 원칙은 표준 라이브러리를 사용하는 것이다
  - 처음으로 프로그래밍 대회에 참가하는 학생들이 가장 자주 저지르는 실수는 큐나 스택과 같은 자료구조, 혹은 정렬 등의 기초적 알고리즘을 직접 작성하는 것이다
  - 표준 라이브러리는 셀 수 없을정도로 많이 사용되고 검증되었기 때문에, 메모리 관리나 정당성 증명에 신경 쓸 필요 없이 편하게 사용할 수 있다

## 4. 항상 같은 형태로 프로그램을 작성하기(프로그래밍 대회의 경우)

- 같은 코드를 다른 방식으로 작성하는 것은 실수의 원인이 될 수 있다
  - 코드를 검증한다는 것은 그렇게 쉬운일 이 아니다
- 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있다
  - 그래야 문제에 집중할 수 있다

## 5. 일관적이고 명료한 명명법 사용하기

- 모호한 변수명과 함수명은 실무든, 프로그래밍 대회든 완벽한 낙제감이다
  - `int a[30][30], i, j, p[1000], k=0, l=-1` (X)
- 모호한 명명법은 잡기 힘든 오류를 만들어낸다
  - 2차원 평면 상에 한 개의 점과 원이 주어졌을 때 점이 원 안에 포함되는지 여부를 반환하는 함수
    - `bool judge(int y, int x, int cy, int cx, int cr);`
      - 이 코드에서 알 수 있는 것은 두 개의 2차원 좌표와 또 다른 값이 입력으로 주어지고, 좌표의 순서는 y,x순이라는 것 뿐이다
      - 이런 애매한 함수명은 함수를 짤 때는 해당 점이 원 밖에 있을 때 참을 반환했지만, 함수를 사용할 때는 해당 점이 원 안에 있을 때 참이 반환된다고 생각할 수 있다
      - 이 함수가 언제 참을 반환하는지 알 수 없다
    - `bool inInsideCircle(int y, int x, int cy, int cx, int cr)`
      - 같은 함수지만 함수 이름만 바꾸면 훨씬 명료해진다

## 6. 모든 자료를 정규화해서 저장하기

- 같은 자료를 두 가지 형태로 저장하지 않는 것이 좋은 코드의 원칙이다
- 예를 들어 문자열을 다루는 프로그램이라면, 인코딩이 이것저것 섞여있는 문제가 있을 수 있다
  - 외부에서 문자열을 읽어들이자마자 가능한 UTF-16이나 UTF-8 인코딩으로 변환해야 문자열을 다루기 훨씬 편해진다

## 7. 코드와 데이터를 분리하기

- 날짜를 다루는 프로그램을 작성하는데, 날짜를 출력할 때 월을 숫자가 아니라 영문 이름으로 출력해야 할 경우
  - 가장 많이 하는 실수는 열두 줄 짜리 함수를 짜는 것이다
  ```cpp
  string getMonthName(int month) {
    if(month == 1) return "January";
    ...
    return "December";
  }
  ```
  - 코드의 논리와 상관 없는 데이터는 가능한 분리하는게 좋다
  ```cpp
  const string monthName[] = {"January", "February", ... "December"};
  ```
  - 하지만 해당 방식도 상수 오타에 대한 위험이 존재하며, 이 오류는 컴파일러가 잡지 못해 굉장히 위험할 수 있다

## 자주 하는 실수들

### 실수 연산

- 실수 연산은 부동소수점(32bit, 64bit)를 이용하기해 정밀도의 문제가 언제든 발생가능하다
  - 이 문제를 다 제어할수 있으면 좋겠지만, 가장 좋은 방법은 64bit를 사용하거나 최대한 실수 연산을 피하는 것이다

### 배열 범위 밖 원소에 접근

- C/C++는 배열의 원소에 접근할 때 해당 인덱스가 배열의 범위 안에 있는지 별도로 확인하지 않는다
  - 이 특성은 속도가 중요할 때는 좋지만, 배열 범위를 벗어난 값에 접근하는 버그는 찾기 힘들다
  - 런타임 스택 등을 건드려서 프로그램 런타임 오류가 발생하면 다행이지만, 오류가 생기지 않으며 틀린 답을 내놓는 경우도 있다
  ```cpp
  int array[10], t;
  ```
  - 이 때 변수 array, t가 메모리 상에 연속해서 위치하게 된다면 array[10] 위치에 값을 대입하면 t에 있던 값이 덮어씌워진다
    - 이 접근은 런타임 에러도 없으며, 매우 찾기 어려운 버그가 된다
  - 대부분의 오류는 0으로 하는 시작범위와, 1로 시작하는 범위를 혼동하는 것이므로 조심해서 사용해야한다

### 일관되지 않는 범위 표현 방식 사용하기

- 범위 표현의 방식에는 크게 2가지 방식이 존재한다
  1. 열린 구간: (2, 12) 는 [3,4 ... , 11]를 나타낸다
  2. 닫힌 구간: [2, 12] 는 [2,3, ..., 12]를 나타낸다
- 이 두가지는 모두 나름의 단점이 존재한다
  - 닫힌 구간의 문제는 공집합을 우아하게 표현할 수 없다
    - 공집합을 표현하고 싶다면 a>b인 범위 [a, b] 를 쓰는 수밖에 없다(직관적이지 않다)
  - 열린 구간의 경우는 배열의 첫 번쨰 원소부터 시작하는 범위를 표현하고 싶을 경우 첫 번째 원소 이전에 존재하는 가상의 원소를 사용해야한다
- 그래서 대부분의 프로그래밍 언어는 이 둘 사이의 절충안인 반 열린 구간을 사용한다(0<= x < n)
- 이런 범위 선택 때문에 프로그램 내에서 한 가지 방법으로만 범위를 표현하는 것은 매우 중요하다
  - 프로그래밍 언어가 지원하는 범위 표현 방식을 따르는 것이 가장 효율적이다

### Off-by-one 오류

- 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가리킨다
  - 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 것이 중요하다

### 컴파일러가 못 잡아주는 상수 오타

- 변수명이나 함수명에서 낸 오타는 컴파일러가 잡아준다
  - 하지만 상수는 컴파일러가 잡아주지 못해 잘못 입력해서 틀릴 수 있다
  - 상수는 집중해서 입력해야한다

### 다차원 배열 인덱스 순서 바꿔쓰기

- 2차원 이상의 다차원 배열을 사용할 일이 많이 없지만, 프로그래밍 대회에서는 심심찮게 사용한다
  - 여기저기 접근하다보면 한군데쯤에서 인덱스의 순서를 헷갈리는 일이 있다
  - 이런 경우는 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다

### 연산자 우선순위 잘못 쓰기

- 연산자 우선순위는 종종 잡기 힘든 버그를 만든다
- 시프트나 비트연산시 주의해야 한다
  - `if(b&1 == 0)`
  - 해당 연산의 경우는 b의 최하비트가 0일때 참인 것 처럼 보인다
  - 하지만 비트 연산은 AND 연산자인 &의 우선순위는 비교 연산자인 ==보다도 낮기 때문에 해당 if문의 해석은 
    - `if(b&(1 ==0 ))`이 되며, 언제나 false가 되어 주의가 필요하다

### 변수 초기화 문제

- 많은 프로그래밍 대회에서는 프로그램을 한 번만 실행하고, 한 번에 여러개의 입력에 대한 답을 처리하라고 요구한다
  - 가장 흔한 실수는 이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것이다
  - 초기화하지않고 그대로 사용한다면 전혀 다른 답이 나올 수 있다

## 디버깅 방법

- 재귀/ 중복 반복문은 디버거로 디버깅이 매우 어렵다
- 프로그래밍 대회의 짧은 코드는 디버거보다 눈으로 디버깅하는 쪽이 훨씬 빠르고 편하다
- 디버거 대신 사용할만한 방법은 다음과 같다
  1. 작은 입력에 대해 제대로 실행되나 확인하기
  2. 단정문(assertion)을 쓴다
      - 단정문은 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문을 의미한다
      - 주어진 조건이 참일 때는 무시되고, 거짓일 때만 오류를 내무로 프로그램의 내부 상태를 검증할 때 유용하게 쓸 수 있다
  3. 프로그램의 계산 중간 결과를 출력
      - 찍어본다 