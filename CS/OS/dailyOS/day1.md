# OS 구조와 원리 

> 책을 보고 응용해 OS를 만들어보는 것이 목적

> https://github.com/gunhaa/LoopyOS

> https://www.yes24.com/Product/Goods/2508562

- nas를 이용한 부트섹터 생성, 어셈블러를 이용해 바이너리(img)로 컴파일 한다
```assembly
; loopy-os
; TAB=4

; binary로 작성하기 어려워, 바이너리로 작성한 것을 코드로 작성하는 것이다
; 표준적인 FAT12 포맷 플로피 디스크를 위한 서술

DB 0xeb, 0x4e, 0x90
DB "LoopyIPL" ; 부트섹터의 이름
DW 512 ; 1섹터의 크기(바이트 단위, 512)
DB 1 ; 클러스터의 크기(1섹터)
DW 1 ; 예약된 섹터의 수
DB 2 ; 디스크의 FAT 테이블 수
DW 224 ; 루트 디렉토리 엔트리의 수(보통은 224엔트리)
DW 2880 ; 디스크의 총 섹터 수(2880임, 플로피 디스크)
DB 0xf0 ; 미디어 타입(0xf0으로 해야함, 1.44mb 플로피디스크)
DW 9 ; 하나의 FAT 테이블의 섹터 수(9섹터로 해야함)
DW 18 ; 1트랙에 몇 섹터가 있는가(18로 해야함)
DW 2 ; 헤드의 수(2로 해야함)
DD 0 ; 파티션을 사용하지 않으므로 이곳은 반드시 0
DD 2880 ; 이 드라이브의 크기를 한번 더 씀
DB 0,0,0x29 ; 볼륨 ID가 포함된 부트 섹터임을 표시하는 마커
DD 0xffffffff ; 볼륨의 시리얼 번호
DB "Loopy-OS    " ; 디스크의 이름
DB "FAT12    " ; 포맷의 이름
RESB 18 ; 18바이트 남겨둠

; 부트 로더 실행 코드를 포함하는 부분. 여기서 CPU 모드를 16비트 리얼 모드(real mode)로 설정하고, 실행을 시작함.

DB 0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
DB 0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
DB 0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
DB 0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
DB 0xee, 0xf4, 0xeb, 0xfd

; 메시지 부분

DB 0x0a, 0x0a ; 줄바꿈 2개
DB "LoppyOS, hello world"
DB 0x0a ; 줄바꿈
DB 0

RESB 0x1fe-$ ; 0x001fe 까지를 0x00으로 채우는 명령, MBR의 끝(510바이트)을 의미
DB 0x55, 0xaa ; MBR인지 확인해주는 마커

; 이하는 부트섹터 이외의 부분에 기술
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 4600
DB 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
RESB 1469432
```

- DB명령은 'data byte'의 약어로, 파일의 내용을 1바이트만 직접 쓰는 명령이다
    - 어셈블러 세계의 최종병기로, DB 명령만 있으면 어떤 프로그램도 만들 수 있다
    - 즉 어셈블러로 만들 수 없는 파일은 없다(텍스트 파일, 그림 파일 등 모든 것)
- RESB명령은 'reserve byte'의 약어로, 바이트를 띄워놓는다는 의미이다
    - 이 바이트는 예약의 의미를 가지고있으며, 0x00으로 채워놓는다
    - 여기서는 0x00을 많이 쓰는 대신에 사용한다
- DW 명령은 'data word'의 약어로 word는 어셈블러의 세계에서 16비트의 의미를 갖는다(2바이트)
- DD 명령은 'data double-word'의 약어로 16비트의 의미를 갖는다(4바이트)
- 직접 바이너리 에디터를 사용해 이미지 빌드 후, 이러면 인간이 코딩하기 어렵다는 것을 확인 한 후
- Nask(NASM의 최적화, 저자가 만든 어셈블러) 어셈블러를 이용해 어셈블리어를 바이너리로 변환 시킨다
- 배치 파일을 활용해 QEMU(가상환경)에서 OS를 구동시켜 볼 수 있다(원래는 플로피 디스크로 실행)
- 현재 만든방식(MBR 방식)은 헤더에 다양한 정보를 넣어 OS의 상태를 표시한다, 그리고 510바이트에 마커를 넣어 헤더를 알린다
```plaintext
┌──────────────────────────────────┐
│ 부트스트랩 코드 (446바이트)        │  ⬅ 부트로더 실행 코드
├──────────────────────────────────┤
│ 파티션 테이블 (64바이트)           │  ⬅ 디스크의 파티션 정보
├──────────────────────────────────┤
│ 부트 시그니처 (2바이트, 0x55AA)    │  ⬅ MBR인지 확인하는 마커
└──────────────────────────────────┘
```

### run.bat
```bat
copy LoopyOS.img ..\z_tools\qemu\fdimage0.bin
..\z_tools\make.exe -C ..\z_tools\qemu
```
### install.bat
```bat
..\z_tools\imgtol.com w a: LoopyOS.img
```
### 어셈블러 실행(!cons_nt.bat), 바이너리로 변환(img)
```bat
..\z_tools\nask.exe LoopyOS.nas LoopyOS.img
```