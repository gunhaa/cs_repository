# CS 질문 리스트/ 뼈대 답변

> (두괄식 결론) A는 B라는 원리/특징 때문에 C라는 장점과 D라는 단점을 갖습니다. (3~4문장, 30초 내외)

- Q: 프로세스와 스레드란 무엇인가요?
  - 프로세스와 스레드의 핵심 차이는 메모리 공유 여부입니다.
  - 프로세스는 운영체제로부터 자원을 독립적으로 할당받기 때문에 안정성이 높지만, 생성과 컨텍스트 스위칭 비용이 크다는 단점이 있습니다. 반면 스레드는 프로세스 내 자원을 공유하므로 적은 비용으로 빠른 컨텍스트 스위칭이 가능해 응답성이 좋지만, 자원 공유로 인한 동기화 문제가 발생할 수 있다는 단점을 가집니다.
- Q: 대칭키/비대칭키란 무엇인가요?
  - 대칭키와 비대칭키는 사용하는 키의 개수와 관리 방식에 따라 속도와 키 교환의 안전성 측면에서 명확한 장단점을 가집니다. 
  - 대칭키는 암호화와 복호화에 동일한 키를 사용하므로 속도가 매우 빠르다는 장점이 있지만, 이 키를 사전에 안전하게 공유하기 어렵다는 단점이 있습니다. 
  - 반면, 공개키와 개인키로 분리된 비대칭키는 키 교환이 안전하다는 장점이 있지만, 복잡한 연산으로 인해 속도가 매우 느리다는 단점을 갖습니다.
- Q: HTTPS는 무엇인가요?
  -  HTTPS는 안전한 키 교환을 위한 비대칭키 방식과 빠른 데이터 암호화를 위한 대칭키 방식을 함께 사용하는 하이브리드 암호화 통신 규약입니다. 
  -  이 방식은 비대칭키로 세션키를 안전하게 공유한 뒤, 이후의 실제 통신은 속도가 빠른 대칭키로 처리하여 '보안'과 '성능'을 모두 확보하는 장점을 가집니다. 
  -  다만, 초기 연결 시 암호화 키를 교환하는 '핸드셰이크' 과정 때문에 일반 HTTP보다 약간의 지연이 발생할 수 있다는 단점이 있습니다.
- Q: Race Condition 이란 무엇인가요?
  - Race Condition(경쟁 상태)이란, 여러 스레드가 공유 자원에 동시에 접근하여 실행 순서에 따라 결과가 달라지는 문제입니다. 
  - 이는 스레드가 메모리를 공유하며 동작하는 멀티스레딩 환경의 특성 때문에 발생하며, 데이터의 무결성을 깨뜨릴 수 있다는 심각한 단점을 가집니다. 이 문제는 뮤텍스나 세마포어 같은 동기화 기법으로 해결할 수 있지만, 동기화 구현이 잘못될 경우 성능 저하나 교착 상태(Deadlock)를 유발할 수 있어 주의가 필요합니다.
- Q: 분산락이란 무엇인가요?
  - 분산락은 여러 서버가 메모리를 공유하지 않는 분산 시스템 환경에서 데이터의 일관성을 보장하기 위한 동기화 메커니즘입니다. 
  - 이는 Redis와 같은 외부 공유 저장소를 '자물쇠'로 사용하는 원리로, 여러 서버에 걸쳐 공유 자원의 동시 접근을 제어하여 데이터 정합성을 보장하는 장점을 가집니다. 
  - 하지만 락을 관리하는 외부 저장소에 병목이 발생하거나 장애가 생길 경우, 전체 시스템의 성능과 안정성에 영향을 줄 수 있다는 단점이 있습니다.
- Q: System Call이란 무엇인가요?
  - 시스템 콜은 사용자 프로그램이 운영체제 커널의 기능을 요청하기 위한 공식적인 통로(인터페이스)입니다. 
  - 이는 시스템 자원을 보호하기 위해 사용자 모드와 커널 모드를 분리하는 원리에 기반하며, 이 구조 덕분에 운영체제는 하드웨어에 대한 직접적인 접근을 막아 시스템 전체의 안정성을 확보하는 장점을 가집니다. 
  - 하지만 호출될 때마다 사용자 모드에서 커널 모드로의 전환(Context Switch)이 발생하여, 상당한 성능 오버헤드가 수반된다는 단점이 있습니다.
- Q: REST API란 무엇인가요?
  - REST API는 자원을 URI로 표현하고 그에 대한 행위를 HTTP 메서드로 명시하는, 웹의 장점을 최대한 활용하는 아키텍처 스타일입니다. 
  - 이 방식은 URI와 메서드만으로도 API의 의도를 명확히 알 수 있어 직관적이고, HTTP 표준을 따르므로 범용성이 높다는 장점을 가집니다. 
  - 하지만 서버에서 정의한 고정된 자원 구조를 따라야 하므로, 클라이언트 입장에서 필요한 것보다 많거나(Over/under fetching) 적은 데이터를 받는 비효율이 발생할 수 있다는 단점이 있습니다.
- Q: GRAPHQL은 무엇인가요?
  - GraphQL은 클라이언트가 필요한 데이터 구조를 직접 정의하여 요청하는 애플리케이션 계층의 쿼리 언어입니다. 
  - 이 방식은 클라이언트가 필요한 만큼만 데이터를 정확히 받아올 수 있어 REST API의 고질적인 Over-fetching과 Under-fetching 문제를 해결하는 명확한 장점을 가집니다. 
  - 하지만 모든 요청이 단일 엔드포인트로 집중되기 때문에, 개별 요청에 대한 캐싱이나 인증/인가 구현이 REST API보다 복잡해진다는 단점이 있습니다.
- Q: DNS가 무엇이며, 어떻게 작동하나요?
  - DNS는 사람이 읽기 쉬운 도메인 이름(예: https://www.google.com/search?q=google.com)을 컴퓨터가 통신에 사용하는 IP 주소로 변환해주는, 인터넷의 분산 데이터베이스 시스템입니다. 
  - 이는 전 세계에 흩어진 서버들이 계층적으로 질의를 주고받아 IP 주소를 찾아내는 원리로 동작하며, 사용자가 복잡한 숫자를 외울 필요 없이 편리하게 웹에 접근하게 해주는 장점을 가집니다. 
  - 하지만 IP 주소를 찾는 조회 과정에서 약간의 지연이 발생할 수 있고, DNS 스푸핑과 같은 보안 공격에 취약할 수 있다는 단점이 있습니다.
- Q: TCP와 UDP의 차이점은 무엇인가요?
  - TCP와 UDP의 핵심 차이는 '연결 설정'과 '데이터 전송 제어 기능'의 유무에서 비롯되는 신뢰성과 속도의 트레이드오프입니다. 
  - TCP는 3-way-handshake로 연결을 설정하고 데이터 흐름과 오류를 제어하는 원리 덕분에 데이터 전송의 신뢰성이 높다는 장점을 갖지만, 그만큼 오버헤드가 커서 속도가 느립니다. 
  - 반면 UDP는 이러한 제어 기능 없이 데이터를 일방적으로 전송하므로 속도가 매우 빠르다는 장점이 있지만, 데이터의 유실이나 순서 변경이 발생할 수 있어 신뢰성이 낮다는 단점을 가집니다.
- Q: HTTP 프로토콜은 무엇인가요?
  - HTTP는 웹에서 클라이언트와 서버가 통신하기 위한 '요청-응답' 기반의 프로토콜입니다. 
  - 이는 연결을 유지하지 않는 '무상태(Stateless)' 특성을 기반으로 동작하기에, 구조가 단순하고 서버 확장성을 확보하기 용이하다는 장점을 가집니다. 
  - 하지만 매 요청마다 연결을 맺고 끊는 오버헤드가 발생하며, 상태 유지를 위해 쿠키나 세션 같은 별도의 기술이 필요하다는 단점이 있습니다.
- Q: 웹 브라우저에 naver.com을 입력하면 무슨일이 일어나나요?
  - 웹 브라우저에 URL을 입력하는 것은, 사람이 사용하는 도메인 주소를 컴퓨터가 이해하는 IP 주소로 변환하여 웹 콘텐츠를 가져와 화면에 표시하는 일련의 과정입니다. 
  - 이 과정은 브라우저 캐시, hosts 파일, DNS 서버 순의 계층적 주소 조회를 거쳐 TCP 연결을 맺고 HTTP 요청을 보내는 원리로 동작하며, 사용자가 복잡한 IP를 몰라도 웹을 편리하게 이용할 수 있게 해주는 장점을 가집니다. 
  - 하지만 DNS 조회, TCP 핸드셰이크 등 여러 네트워크 통신 단계를 거치기 때문에 페이지 로딩에 지연이 발생할 수 있다는 단점이 있습니다.
- Q: 동기, 비동기는 무엇인가요?
  - 동기와 비동기는 작업의 흐름을 제어하는 방식의 차이로, 코드의 단순성과 시스템의 처리 효율성 측면에서 명확한 장단점을 가집니다. 
  - 동기 방식은 요청한 작업이 끝날 때까지 기다리는 원리이므로 흐름이 단순하고 예측이 쉽다는 장점이 있지만, 대기 시간 동안 다른 작업을 못 해 시스템 효율이 떨어지는 단점이 있습니다.(제어권 안넘겨줌) 
  - 반면 비동기 방식은 작업 완료를 기다리지 않고 즉시 다음 코드를 실행하므로 시스템의 처리 효율을 극대화하는 장점이 있지만, 코드의 흐름이 복잡해지고 결과 처리 순서를 예측하기 어렵다는 단점을 갖습니다.(제어권 줌)
- Q: Blocking, non-blocking은 무엇인가요?
  - Blocking과 Non-blocking은 호출된 함수의 작업 완료를 기다리는지, 즉 '제어권'을 즉시 반환하는지 여부에 따라 시스템 효율성과 구현 복잡성에서 명확한 차이를 보입니다. 
  - Blocking은 작업이 끝날 때까지 제어권을 돌려주지 않고 대기하는 방식으로, 구현이 간단하지만 해당 스레드가 멈춰 시스템 효율을 떨어뜨리는 단점이 있습니다. 
  - 반면 Non-blocking은 즉시 제어권을 반환하여 시스템 자원을 효율적으로 쓸 수 있는 장점이 있지만, 작업 완료 여부를 계속 확인해야 하므로 로직이 복잡해질 수 있다는 단점을 가집니다.
