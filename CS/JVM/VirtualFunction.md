# Java의 메소드는 invokevirtual을 사용하는 것이 기본이다

## 자바 바이트코드에는 호출 방식이 4가지가 있다

1. invokevirtual : 인스턴스 메서드 호출 → 런타임에 실제 구현체를 찾아야 함
2. invokestatic : static 메서드 호출 → 컴파일타임에 대상이 확정됨
3. invokespecial : private, 생성자, super 호출 → 마찬가지로 컴파일타임에 확정
4. invokeinterface : 인터페이스 메서드 호출 → 마찬가지로 런타임에 탐색
- 즉 일반적인 인스턴스 메서드는 invokevirtual을 쓰기 때문에 가상 함수 테이블(vtable)을 참조해 런타임에 연결된다

## 왜 인스턴스의 메소드를 런타임에 결정해야 하나?

- “구현체를 아는 경우에도 왜 정적 바인딩을 안 하고 굳이 런타임에 동적 바인딩을 하느냐?”는 질문은 언어 설계 + JVM 구현 철학 때문이다
  - 자바는 모든 인스턴스 메서드 호출은 다형성(polymorphism)이 적용될 수 있다는 규칙을 따른다
  - 그래서 기본적으로 invokevirtual(가상 호출)로 컴파일한다

### “구현체를 아는 경우”인데 왜 동적 바인딩을?

```java
Child c = new Child();
c.hello();
```

- Q: 이 경우컴파일러는 c가 Child라는 것을 안다, 그럼 정적 바인딩으로 최적화할 수 있지 않을까?
- A: 이 부분은 언어 명세의 단순함과 JVM 최적화 전략 때문임
  - 언어 명세 차원: 모든 인스턴스 메서드 호출은 기본적으로 invokevirtual로 통일 → 일관성 있는 바이트코드 구조
  - JVM 최적화 차원: JIT 컴파일러가 런타임 프로파일링을 통해 “항상 Child만 쓰이네?”라고 판단하면 인라인 캐싱 / 가상 호출 제거(Devirtualization) 같은 최적화를 적용한다
  - 즉, 정적 바인딩 여부를 컴파일러가 아니라 JIT이 동적으로 최적화한다