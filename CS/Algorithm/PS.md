# Problem Solving 전략

> 코드는 문제의 논리적 모델을 그대로 반영하는 거울이다

- 이 철학을 바탕으로, 문제 해결의 기본 원칙들을 정리한다

## PS의 기본 철학 5원칙

#### 제1원칙: 문제는 '이해'하는 것이지 '읽는' 것이 아니다.

- 코딩을 시작하기 전, 가장 많은 시간을 써야 하는 단계이다. 많은 초심자들이 문제를 한번 슥 읽고 바로 키보드에 손을 올린다. 이는 설계도 없이 집을 짓는 것과 같다.
  - 입력 파악: 입력의 종류, 범위, 개수를 정확히 파악해야 한다.
  - 출력 파악: 출력의 형식, 순서, 예외 상황을 명확히 해야 한다.
  - 제약 조건 분석: 시간제한, 메모리 제한, 데이터의 특성을 분석해야 한다.
  - 요구사항의 본질 파악: 예시 입출력에만 매몰되지 말고, 문제가 근본적으로 요구하는 것을 파악해야 한다.

- 문제를 완벽히 이해했다면, 어떤 길로 가야 할지 절반은 결정된 셈이다.

#### 제2원칙: 코드는 '논리의 번역'이다.

문제를 이해했다면, 머릿속에는 해결을 위한 논리적 흐름, 즉 '모델'이 생긴다. 코딩은 이 모델을 컴퓨터가 알아들을 수 있는 언어로 정확하게 번역하는 과정일 뿐이다.

- 표현과 모델링: "두 사람 사이의 관계"는 그래프로, "구간의 합"은 누적 합 또는 세그먼트 트리로, "가장 빠른 길"은 BFS나 다익스트라로 모델링한다. 여기서 적절한 자료구조와 알고리즘이 선택된다.
- 변수명과 구조: `x`, `y`가 아니라 `row`, `col`을 쓰는 것, `dfs()` 함수의 역할이 명확한 것 등은 모두 머릿속의 논리 모델을 코드가 얼마나 잘 표현하고 있는지를 보여주는 척도이다. 코드를 읽는 것만으로도 풀이법이 설명되어야 한다.

#### 제3원칙: '대충'은 가장 큰 적이다 - 정밀성과 예외 처리

- "이 정도면 되겠지"라는 안일함이 PS에서 가장 경계해야 할 태도이다. 컴퓨터는 단 하나의 예외도 용납하지 않는다.

  - 자료형(Type): 더하는 숫자가 10억 두 개인데 `int`를 쓰는가? 결과가 21억을 넘을 수 있다면 당연히 `long`을 써야 한다.
  - 경계값(Boundary): `i < N` 인가, `i <= N` 인가? 배열의 인덱스가 0부터 시작하는가, 1부터 시작하는가? 반복문이 0번 혹은 1번만 돌 때도 올바르게 동작하는지 확인해야 한다.
  - 예외 케이스(Edge Case): 입력이 비어있을 때, 모든 입력이 같을 때, N=1일 때 등 극단적인 상황을 반드시 고려해야 한다.
- '대충' 짠 코드는 수많은 '틀렸습니다'의 원인이 되며, 디버깅에 몇 배의 시간을 쏟게 만든다.

#### 제4원칙: '왜?'라고 질문하라 - 시간 복잡도와 효율성

- "일단 이중 for문으로 돌려보자"는 PS의 철학이 아니다. 모든 코드 라인에는 "왜 이것이 효율적인가?"라는 질문이 따라붙어야 한다.
  - N의 최대 크기가 100,000인데 $O(N^2)$ 알고리즘을 떠올렸다면, 그 즉시 "이건 시간 초과다. 왜 안될까? 더 나은 방법은 없을까?"라고 자문해야 한다.
  - "왜 여기서 정렬을 해야 하는가?", "왜 여기서는 큐(Queue)를 써야 하는가?"와 같은 질문은 풀이의 정당성을 부여하고, 더 효율적인 해법으로 가는 길을 열어준다.
- 시간 복잡도에 대한 이해는 단순 구현가를 넘어 진짜 'Problem Solver'로 가는 필수 관문이다.

#### 제5원칙: 일관성은 코드의 '신뢰도'다

- `visited[x][y]`와 `visited[y][x]`에 대한 논의가 이 원칙의 핵심이다.

  - `x`를 행으로 쓰기로 했으면, 코드의 시작부터 끝까지 `x`는 행이어야 한다. 중간에 갑자기 열로 쓰면 코드는 신뢰를 잃고 버그의 온상이 된다.
  - 들여쓰기, 변수명 규칙, 중괄호의 위치 등 사소해 보이는 스타일조차 일관성을 지키면 코드의 가독성이 높아지고, 실수를 줄여준다.
  - 일관성 있는 코드는 다른 사람이 읽기에도 좋지만, 몇 분 뒤의 나 자신이 디버깅하기에도 좋다.

### 결론

- 결국 PS는 단순히 '정답' 코드를 제출하는 행위가 아니라, "주어진 문제를 깊이 이해하고, 최적의 논리 모델을 설계한 뒤, 이를 한 치의 오차도 없이 정밀하고 일관된 코드로 번역해내는 종합적인 지적 훈련"이다.
- 이러한 철학을 가지고 코드를 대할 때, 비로소 '대충 만든 코드'가 아닌, 문제의 본질을 꿰뚫는 '아름다운 코드'를 작성할 수 있게 된다.
