# (Data) Link Layer(Ethernet)

- 하나의 LAN(Local Area Network) 내에서 장치 간 데이터를 전송하기 위한 프로토콜
  - 링크 계층의 기본 서비스는 단일 통신 링크상으로 데이터그램을 한 노드에서 인접 노드로 '이동' 시키는 것이다
  - 링크 계층의 프로토콜이 제공하는 서비스는 다음과 같다
    1. 프레임화: Network layer의 packet을 frame으로 캡슐화한다
    2. 링크 접속: 매체 접속 제어(mediun access control, MAC) protocol은 링크상 프레임을 전송하는 규칙을 명시한다. point to point의 경우 단순하게 동작하며, 하나의 broadcast link를 공유하는 경우 MAC이 node로부터의 전송을 조정한다 
    3. 신뢰적 전달: 신뢰적 전달 기능을 제공하는 경우 링크상에서 오류없이 전달된다. (TCP와 같은) 일부 트랜스포트 계층 프로토콜에서는 신뢰적 전달 서비스를 제공한다
    4. 오류 검출과 정정: 송신 노드에서 오류 검출 비트를 설정하게하고 수신 노드에서 오류 검사를 수행하게 함으로써 가능하다. Link layer의 일반적인 서비스이다
- 링크 계층은 두 종류가 있다
  1. 브로드 캐스트 채널(무선랜, 위성 네트워크)
  2. point to point(원거리 링크에 의해 연결된 두 라우터 또는 사용자의 사무실 컴퓨터와 이더넷 스위치 사이)
- 링크 계층은 네트워크 인터페이스 컨트롤러(Network Interface Controller, NIC)로 알려진 네트워크 어댑터에 구현된다
  - NIC에서 link layer service의 동작이 구현되어있다(packet to frame, link connect, 오류 검출)
    - 물리적으로 인접한 두 장치(호스트 ↔ 스위치, 스위치 ↔ 스위치 등) 사이의 데이터 링크 계층 수준의 연결
    - MAC 주소를 기반으로 한 연결 인식 및 통신 관계 형성이 핵심

## 용어

- backoff algorithm
  - 충돌 후 잠시 물러서서 다시 전송하는 절차
- node
  - 링크 계층에서 프로토콜을 실행하는 장치
  - wifi access point, switch, router, host

## 오류 검출 및 정정

### 패리티 검사

- parity bit를 사용해 오류를 검출한다
  - 짝수(홀수) 패리티: d의 길이에 비트를 추가하고 d+1개의 합이 짝수(홀수)가 되도록하는 것
  - 문제: 짝수개의 오류는 확인 불가

### 체크섬

- TCP/UDP에서 주로 사용되는 방법이다
  - 데이터를 여러 블록으로 나누고, 이들을 더한 합의 보수를 전송 시 포함
  - 수신 측에서 다시 더해 합이 0(또는 0xFFFF) 이 되면 정상으로 간주
- 체크섬 방식은 CRC에 비하면 오류 면에서 상대적으로 취약하다
  - link layer에서는 주로 CRC방식을 사용한다

### CRC Cyclic Redundancy Check

- 데이터 비트를 이진 다항식(binary polynomial) 으로 보고, 송신 측에서 미리 정해진 생성 다항식(G(x)) 으로 나누어 나머지(R) 를 붙여 전송
- 계산 복잡도가 다소 높아 소프트웨어 계층보다는 하드웨어 구현에 적합해서 link layer에서 사용된다

#### 왜 검증을 Transport(TCP/UDP), Network Layer 두군데에서 함?

- 링크 계층(Ethernet) 은 패킷의 가장 첫 전달 지점이다
  - 만약 여기서 비트 하나라도 잘못되면, 상위 계층으로 올라가는 모든 데이터가 잘못된다
  - TCP처럼 재전송이 있는 계층과 달리, 링크 계층은 “오류만 검출하고 폐기(drop)” 하는 역할이므로 거의 완벽하게 오류를 검출할 필요가 있다
- 계층마다 “책임 범위”가 다르기 때문이다
  - CRC와 체크섬은 중복이 아니라 보장 범위가 다른 “이중 안전망” 이다
- CRC는 “링크(구간)” 단위만 보장
  - 패킷이 LAN 한 구간을 지나갈 때마다 해당 구간의 하드웨어(NIC, 스위치)가 CRC를 검증하고 오류 있으면 폐기(drop) 다음 구간으로 갈 때는 새로 계산된 CRC를 붙인다.
  - 즉, CRC는 “매 홉(hop)” 마다 새로 생성되고, 전송 중 변경될 수 있다
- TCP/UDP 체크섬은 “종단 간(end-to-end)” 보장
  - 즉, 송신 애플리케이션 → 수신 애플리케이션까지 전체 경로(End-to-End) 에 대해 데이터를 보장하기 위함이다
  - 중간 라우터들은 IP 헤더만 수정하고(예: TTL 감소, 헤더 체크섬 다시 계산), 데이터(payload)는 건드리지 않지만, 전송 중 다른 이유로(버그, 메모리 오류, 드라이버 손상 등) 데이터가 변형될 수 있다
  - 그래서 TCP/UDP는 “전송 중 링크가 바뀌더라도, 최종 수신자가 받은 데이터가 송신자가 보낸 데이터와 일치하는가?”를 확인하기 위해 체크섬을 한 번 더 수행한다

## 다중 접속 제어 (Multiple Access Control) 문제

- `다수의 송수신 노드들의 공유되는 브로드 캐스트 채널로의 접속을 조정하는 문제`
- `동시에 두 장치가 송신하면 신호가 섞여 “충돌(collision)”이 발생한다는 것`
- 링크 계층의 다중 접속 제어는 “여러 노드가 공유 자원에 접근할 때 충돌을 막는” 문제로, 이는 곧 운영체제와 데이터베이스의 동시성 제어(concurrency control) 개념의 가장 초기 형태이자 원조격이다

| 네트워크 기법 | 동작 요약 | 동시성 제어 관점 대응 | 상세 설명 |
|----------------|------------|------------------------|-------------|
| **ALOHA / Slotted ALOHA** | 충돌을 허용하고 실패 시 무작위 지연 후 재전송한다. 슬롯을 도입하면 충돌 확률을 더 낮춘다. | **낙관적 동시성 제어 (Optimistic Concurrency Control)** | 매체 사용을 선점하지 않고 즉시 전송하며, 충돌이 발생하면 무작위 지연 후 재시도한다. 슬롯을 도입하면 전송 시점을 정렬해 충돌 구간을 줄인다. 구현은 단순하지만 혼잡 시 효율이 낮다. |
| **CSMA/CD (Ethernet)** | 전송 전 채널 유휴 상태를 감지하고, 전송 중 충돌을 감지하면 즉시 중단 후 이진 지수 백오프를 수행한다. | **스핀락 (Spinlock)** | 채널을 지속적으로 감시하며, 비어 있으면 바로 전송을 시도한다. 충돌이 발생하면 잼 신호를 송출하고 잠시 기다린 후 재시도한다. 충돌 시 즉시 정지하는 방식으로 자원 낭비를 최소화한다. |
| **CSMA/CA (Wi-Fi)** | 충돌 감지 대신 경쟁 윈도우 기반 무작위 백오프로 충돌을 사전에 회피한다. | **뮤텍스 (Mutex)** | 무선에서는 충돌 감지가 불가능하므로, 송신 전에 무작위 백오프와 DIFS/EIFS 대기를 수행한다. 경쟁 구간을 줄이기 위해 RTS/CTS를 사용하여 숨은 단말 문제를 완화한다. 자원을 선점하기 전까지 대기 상태를 유지한다. |
| **Token Passing (Token Ring, FDDI)** | 토큰을 보유한 노드만 전송하여 충돌을 원천적으로 제거한다. | **토큰 기반 락 (Token-based Mutual Exclusion)** | 네트워크 상에 하나의 토큰만 존재하며, 토큰을 가진 노드만 전송 권한을 가진다. 충돌이 원천적으로 제거되지만, 토큰 분실 시 복구 절차가 필요하다. 지연은 예측 가능하다. |

- ALOHA는 “일단 실행하고 충돌 시 randomize 재시도” → 낙관적 트랜잭션
- CSMA/CD는 “계속 감시하며 즉시 진입 시도 → 충돌 시 바로 멈춤” → CPU 스핀락과 유사
- CSMA/CA는 “선점 전 대기 → 자원 확보 후 실행” → 전형적인 뮤텍스 구조
- Token Passing은 “권한을 명시적으로 전달” → 토큰 락

### Ethernet의 원형 Aloha net

- 아무때나 전송하고, 충돌나면 재전송하는 최초의 무선 통신(효율 18%)
- 이를 피드백해서 CSMA/CD로 발전하였다

## Ethernet

> MAC과 ARP protocol을 이용한 근거리 네트워크 통신 기술

- Ehternet gateway를 통해 google(8.8.8.8)로 보내는 과정
  - LAN에서는 NIC에서 Ethernet header를 앞부분만 까서 MAC만 먼저 확인한다(LAN 목적지 확인)
  - Ehternet header 제거 후 IP header를 확인해 목적지(dst)를 확인한다
  - 라우팅 테이블 검색해 다음 홉(next hop, 다음 라우터)을 확인한다
  - Ehternet frame을 새로 생성한다(MAC주소는 다음 라우터/next hop)
    - dst = Router IP까지 진행된다
    - next hop(Router)의 MAC을 라우팅 테이블(IP 질의)/ARP(MAC 질의)를 통해서 계속 질의해가며 진행된다
  - 즉 라우터간 통신은 “IP 주소는 그대로 유지한 채, MAC 주소만 홉(hop)마다 바꿔 붙이며, 목적지 IP가 일치하는 곳까지 전달되는 과정”이다

### MAC (Media Access Control Address)

- NIC에 고유하게 부여된 48비트 식별자(e.g. 00:1A:2B:3C:4D:5E)
- 같은 LAN 내부에서 프레임을 목적지까지 전달할 때 사용
- IP주소는 논리적이지만, MAC주소는 물리적 주소
  - IP: 어디로 보내야 하는가(논리적 위치)
  - MAC: 물리적으로 어느정치에게 보낼 것인가
- 이더넷 프레임의 목적지/출발지 주소로 사용됨

### ARP (address Resoulution Protocol)

- IP주소로부터 해당 장치의 MAC주소를 알아내는 protocol
- Network Layer에서 캡슐화 전에 ARP를 사용해서 MAC주소 요청후 헤더에 추가시킨다(캡슐화)
- IP주소로 ARP를 써야하는지는 서브넷 마스크를 보고 판별한다
  - 내 IP: `192.168.0.2`
  - 상대 IP: `192.168.0.10`
  - 서브넷마스크: `255.255.255.0`
  - → 같은 네트워크이므로 라우터를 거치지 않음.
  - 다른 네트워크(`8.8.8.8`)이라면 라우터를 이용해 WAN에 연결해 목적지로 패킷을 전송함(게이트웨이의 MAC주소가 포함 됨)

#### 동작 과정

1. PC가 192.168.0.10에게 데이터를 보내려 함
2. 자신의 ARP 캐시 테이블을 확인 (IP → MAC 매핑)
3. 없으면 ARP Request(브로드캐스트) 전송
- "192.168.0.10 인 사람, MAC 주소 알려줘!"
4. 해당 IP를 가진 장치가 ARP Reply(유니캐스트)로 응답
- "나야! 내 MAC은 00:11:22:33:44:55야."
5. 송신자는 이 정보를 ARP 캐시 테이블에 저장